This is pspp.info, produced by makeinfo version 7.0.3 from pspp.texi.

This manual is for GNU PSPP version 2.0.1, software for statistical
analysis.

   Copyright © 1997, 1998, 2004, 2005, 2009, 2012, 2013, 2014, 2016,
2019, 2020, 2023 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".
INFO-DIR-SECTION Math
START-INFO-DIR-ENTRY
* PSPP: (pspp).             Statistical analysis package.
* PSPPIRE: (pspp).          Graphical user interface to PSPP.
END-INFO-DIR-ENTRY


File: pspp.info,  Node: REGRESSION,  Next: RELIABILITY,  Prev: RANK,  Up: Statistics

15.17 REGRESSION
================

The ‘REGRESSION’ procedure fits linear models to data via least-squares
estimation.  The procedure is appropriate for data which satisfy those
assumptions typical in linear regression:

   • The data set contains n observations of a dependent variable, say
     Y_1,...,Y_n, and n observations of one or more explanatory
     variables.  Let X_{11}, X_{12}, ..., X_{1n} denote the n
     observations of the first explanatory variable; X_{21},...,X_{2n}
     denote the n observations of the second explanatory variable;
     X_{k1},...,X_{kn} denote the n observations of the kth explanatory
     variable.

   • The dependent variable Y has the following relationship to the
     explanatory variables: Y_i = b_0 + b_1 X_{1i} + ... + b_k X_{ki} +
     Z_i where b_0, b_1, ..., b_k are unknown coefficients, and
     Z_1,...,Z_n are independent, normally distributed “noise” terms
     with mean zero and common variance.  The noise, or “error” terms
     are unobserved.  This relationship is called the “linear model”.

   The ‘REGRESSION’ procedure estimates the coefficients b_0,...,b_k and
produces output relevant to inferences for the linear model.

* Menu:

* Syntax::                      Syntax definition.
* Examples::                    Using the REGRESSION procedure.


File: pspp.info,  Node: Syntax,  Next: Examples,  Up: REGRESSION

15.17.1 Syntax
--------------

     REGRESSION
             /VARIABLES=VAR_LIST
             /DEPENDENT=VAR_LIST
             /STATISTICS={ALL, DEFAULTS, R, COEFF, ANOVA, BCOV, CI[CONF, TOL]}
             { /ORIGIN | /NOORIGIN }
             /SAVE={PRED, RESID}

   The ‘REGRESSION’ procedure reads the active dataset and outputs
statistics relevant to the linear model specified by the user.

   The ‘VARIABLES’ subcommand, which is required, specifies the list of
variables to be analyzed.  Keyword ‘VARIABLES’ is required.  The
‘DEPENDENT’ subcommand specifies the dependent variable of the linear
model.  The ‘DEPENDENT’ subcommand is required.  All variables listed in
the ‘VARIABLES’ subcommand, but not listed in the ‘DEPENDENT’
subcommand, are treated as explanatory variables in the linear model.

   All other subcommands are optional:

   The ‘STATISTICS’ subcommand specifies which statistics are to be
displayed.  The following keywords are accepted:

‘ALL’
     All of the statistics below.
‘R’
     The ratio of the sums of squares due to the model to the total sums
     of squares for the dependent variable.
‘COEFF’
     A table containing the estimated model coefficients and their
     standard errors.
‘CI (CONF)’
     This item is only relevant if COEFF has also been selected.  It
     specifies that the confidence interval for the coefficients should
     be printed.  The optional value CONF, which must be in parentheses,
     is the desired confidence level expressed as a percentage.
‘ANOVA’
     Analysis of variance table for the model.
‘BCOV’
     The covariance matrix for the estimated model coefficients.
‘TOL’
     The variance inflation factor and its reciprocal.  This has no
     effect unless COEFF is also given.
‘DEFAULT’
     The same as if R, COEFF, and ANOVA had been selected.  This is what
     you get if the /STATISTICS command is not specified, or if it is
     specified without any parameters.

   The ‘ORIGIN’ and ‘NOORIGIN’ subcommands are mutually exclusive.
‘ORIGIN’ indicates that the regression should be performed through the
origin.  You should use this option if, and only if you have reason to
believe that the regression does indeed pass through the origin — that
is to say, the value b_0 above, is zero.  The default is ‘NOORIGIN’.

   The ‘SAVE’ subcommand causes PSPP to save the residuals or predicted
values from the fitted model to the active dataset.  PSPP will store the
residuals in a variable called ‘RES1’ if no such variable exists, ‘RES2’
if ‘RES1’ already exists, ‘RES3’ if ‘RES1’ and ‘RES2’ already exist,
etc.  It will choose the name of the variable for the predicted values
similarly, but with ‘PRED’ as a prefix.  When ‘SAVE’ is used, PSPP
ignores ‘TEMPORARY’, treating temporary transformations as permanent.


File: pspp.info,  Node: Examples,  Prev: Syntax,  Up: REGRESSION

15.17.2 Examples
----------------

The following PSPP syntax will generate the default output and save the
predicted values and residuals to the active dataset.

     title 'Demonstrate REGRESSION procedure'.
     data list / v0 1-2 (A) v1 v2 3-22 (10).
     begin data.
     b  7.735648 -23.97588
     b  6.142625 -19.63854
     a  7.651430 -25.26557
     c  6.125125 -16.57090
     a  8.245789 -25.80001
     c  6.031540 -17.56743
     a  9.832291 -28.35977
     c  5.343832 -16.79548
     a  8.838262 -29.25689
     b  6.200189 -18.58219
     end data.
     list.
     regression /variables=v0 v1 v2 /statistics defaults /dependent=v2
                /save pred resid /method=enter.


File: pspp.info,  Node: RELIABILITY,  Next: ROC,  Prev: REGRESSION,  Up: Statistics

15.18 RELIABILITY
=================

     RELIABILITY
             /VARIABLES=VAR_LIST
             /SCALE (NAME) = {VAR_LIST, ALL}
             /MODEL={ALPHA, SPLIT[(N)]}
             /SUMMARY={TOTAL,ALL}
             /MISSING={EXCLUDE,INCLUDE}

   The ‘RELIABILITY’ command performs reliability analysis on the data.

   The ‘VARIABLES’ subcommand is required.  It determines the set of
variables upon which analysis is to be performed.

   The ‘SCALE’ subcommand determines the variables for which reliability
is to be calculated.  If ‘SCALE’ is omitted, then analysis for all
variables named in the ‘VARIABLES’ subcommand are used.  Optionally, the
NAME parameter may be specified to set a string name for the scale.

   The ‘MODEL’ subcommand determines the type of analysis.  If ‘ALPHA’
is specified, then Cronbach’s Alpha is calculated for the scale.  If the
model is ‘SPLIT’, then the variables are divided into 2 subsets.  An
optional parameter N may be given, to specify how many variables to be
in the first subset.  If N is omitted, then it defaults to one half of
the variables in the scale, or one half minus one if there are an odd
number of variables.  The default model is ‘ALPHA’.

   By default, any cases with user missing, or system missing values for
any variables given in the ‘VARIABLES’ subcommand are omitted from the
analysis.  The ‘MISSING’ subcommand determines whether user missing
values are included or excluded in the analysis.

   The ‘SUMMARY’ subcommand determines the type of summary analysis to
be performed.  Currently there is only one type: ‘SUMMARY=TOTAL’, which
displays per-item analysis tested against the totals.

15.18.1 Example - Reliability
-----------------------------

Before analysing the results of a survey – particularly for a multiple
choice survey – it is desireable to know whether the respondents have
considered their answers or simply provided random answers.

   In the following example the survey results from the file ‘hotel.sav’
are used.  All five survey questions are included in the reliability
analysis.  However, before running the analysis, the data must be
preprocessed.  An examination of the survey questions reveals that two
questions, viz: v3 and v5 are negatively worded, whereas the others are
positively worded.  All questions must be based upon the same scale for
the analysis to be meaningful.  One could use the ‘RECODE’ command
(*note RECODE::), however a simpler way is to use ‘COMPUTE’ (*note
COMPUTE::) and this is what is done in *note Example 15.8:
reliability:ex.

     get file="hotel.sav".
     
     * Recode V3 and V5 inverting the sense of the values.
     compute v3 = 6 - v3.
     compute v5 = 6 - v5.
     
     reliability
     	/variables= all
     	/model=alpha.


Example 15.8: Investigating the reliability of survey responses

   In this case, all variables in the data set are used.  So we can use
the special keyword ‘ALL’ (*note BNF::).

 [image src="screenshots/reliability-ad.png" ]


Screenshot 15.8: Reliability dialog box with all variables selected

   *note Result 15.6: reliability:res. shows that Cronbach’s Alpha is
0.11 which is a value normally considered too low to indicate
consistency within the data.  This is possibly due to the small number
of survey questions.  The survey should be redesigned before serious use
of the results are applied.

 [image src="pspp-figures/reliability.png" text="Scale: ANY

Case Processing Summary
+--------+--+-------+
|Cases   | N|Percent|
+--------+--+-------+
|Valid   |17| 100.0%|
|Excluded| 0|    .0%|
|Total   |17| 100.0%|
+--------+--+-------+

    Reliability Statistics
+----------------+----------+
|Cronbach's Alpha|N of Items|
+----------------+----------+
|             .11|         5|
+----------------+----------+" ]



Result 15.6: The results of the reliability command on ‘hotel.sav’


File: pspp.info,  Node: ROC,  Prev: RELIABILITY,  Up: Statistics

15.19 ROC
=========

     ROC     VAR_LIST BY STATE_VAR (STATE_VALUE)
             /PLOT = { CURVE [(REFERENCE)], NONE }
             /PRINT = [ SE ] [ COORDINATES ]
             /CRITERIA = [ CUTOFF({INCLUDE,EXCLUDE}) ]
               [ TESTPOS ({LARGE,SMALL}) ]
               [ CI (CONFIDENCE) ]
               [ DISTRIBUTION ({FREE, NEGEXPO }) ]
             /MISSING={EXCLUDE,INCLUDE}

   The ‘ROC’ command is used to plot the receiver operating
characteristic curve of a dataset, and to estimate the area under the
curve.  This is useful for analysing the efficacy of a variable as a
predictor of a state of nature.

   The mandatory VAR_LIST is the list of predictor variables.  The
variable STATE_VAR is the variable whose values represent the actual
states, and STATE_VALUE is the value of this variable which represents
the positive state.

   The optional subcommand ‘PLOT’ is used to determine if and how the
‘ROC’ curve is drawn.  The keyword ‘CURVE’ means that the ‘ROC’ curve
should be drawn, and the optional keyword ‘REFERENCE’, which should be
enclosed in parentheses, says that the diagonal reference line should be
drawn.  If the keyword ‘NONE’ is given, then no ‘ROC’ curve is drawn.
By default, the curve is drawn with no reference line.

   The optional subcommand ‘PRINT’ determines which additional tables
should be printed.  Two additional tables are available.  The ‘SE’
keyword says that standard error of the area under the curve should be
printed as well as the area itself.  In addition, a p-value for the null
hypothesis that the area under the curve equals 0.5 is printed.  The
‘COORDINATES’ keyword says that a table of coordinates of the ‘ROC’
curve should be printed.

   The ‘CRITERIA’ subcommand has four optional parameters:
   • The ‘TESTPOS’ parameter may be ‘LARGE’ or ‘SMALL’.  ‘LARGE’ is the
     default, and says that larger values in the predictor variables are
     to be considered positive.  ‘SMALL’ indicates that smaller values
     should be considered positive.

   • The ‘CI’ parameter specifies the confidence interval that should be
     printed.  It has no effect if the ‘SE’ keyword in the ‘PRINT’
     subcommand has not been given.

   • The ‘DISTRIBUTION’ parameter determines the method to be used when
     estimating the area under the curve.  There are two possibilities,
     viz: ‘FREE’ and ‘NEGEXPO’.  The ‘FREE’ method uses a non-parametric
     estimate, and the ‘NEGEXPO’ method a bi-negative exponential
     distribution estimate.  The ‘NEGEXPO’ method should only be used
     when the number of positive actual states is equal to the number of
     negative actual states.  The default is ‘FREE’.

   • The ‘CUTOFF’ parameter is for compatibility and is ignored.

   The ‘MISSING’ subcommand determines whether user missing values are
to be included or excluded in the analysis.  The default behaviour is to
exclude them.  Cases are excluded on a listwise basis; if any of the
variables in VAR_LIST or if the variable STATE_VAR is missing, then the
entire case is excluded.


File: pspp.info,  Node: Matrices,  Next: Utilities,  Prev: Statistics,  Up: Top

16 Matrices
***********

Some PSPP procedures work with matrices by producing numeric matrices
that report results of data analysis, or by consuming matrices as a
basis for further analysis.  This chapter documents the format of data
files that store these matrices and commands for working with them, as
well as PSPP’s general-purpose facility for matrix operations.

* Menu:

* Matrix Files::
* MATRIX DATA::
* MCONVERT::
* MATRIX::


File: pspp.info,  Node: Matrix Files,  Next: MATRIX DATA,  Up: Matrices

16.1 Matrix Files
=================

A matrix file is an SPSS system file that conforms to the dictionary and
case structure described in this section.  Procedures that read matrices
from files expect them to be in the matrix file format.  Procedures that
write matrices also use this format.

   Text files that contain matrices can be converted to matrix file
format.  *Note MATRIX DATA::, for a command to read a text file as a
matrix file.

   A matrix file’s dictionary must have the following variables in the
specified order:

  1. Zero or more numeric split variables.  These are included by
     procedures when ‘SPLIT FILE’ is active.  ‘MATRIX DATA’ assigns
     split variables format F4.0.

  2. ‘ROWTYPE_’, a string variable with width 8.  This variable
     indicates the kind of matrix or vector that a given case
     represents.  The supported row types are listed below.

  3. Zero or more numeric factor variables.  These are included by
     procedures that divide data into cells.  For within-cell data,
     factor variables are filled with non-missing values; for pooled
     data, they are missing.  ‘MATRIX DATA’ assigns factor variables
     format F4.0.

  4. ‘VARNAME_’, a string variable.  Matrix data includes one row per
     continuous variable (see below), naming each continuous variable in
     order.  This column is blank for vector data.  ‘MATRIX DATA’ makes
     ‘VARNAME_’ wide enough for the name of any of the continuous
     variables, but at least 8 bytes.

  5. One or more numeric continuous variables.  These are the variables
     whose data was analyzed to produce the matrices.  ‘MATRIX DATA’
     assigns continuous variables format F10.4.

   Case weights are ignored in matrix files.

Row Types
---------

Matrix files support a fixed set of types of matrix and vector data.
The ‘ROWTYPE_’ variable in each case of a matrix file indicates its row
type.

   The supported matrix row types are listed below.  Each type is listed
with the keyword that identifies it in ‘ROWTYPE_’.  All supported types
of matrices are square, meaning that each matrix must include one row
per continuous variable, with the ‘VARNAME_’ variable indicating each
continuous variable in turn in the same order as the dictionary.

‘CORR’
     Correlation coefficients.

‘COV’
     Covariance coefficients.

‘MAT’
     General-purpose matrix.

‘N_MATRIX’
     Counts.

‘PROX’
     Proximities matrix.

   The supported vector row types are listed below, along with their
associated keyword.  Vector row types only require a single row, whose
‘VARNAME_’ is blank:

‘COUNT’
     Unweighted counts.

‘DFE’
     Degrees of freedom.

‘MEAN’
     Means.

‘MSE’
     Mean squared errors.

‘N’
     Counts.

‘STDDEV’
     Standard deviations.

   Only the row types listed above may appear in matrix files.  The
‘MATRIX DATA’ command, however, accepts the additional row types listed
below, which it changes into matrix file row types as part of its
conversion process:

‘N_VECTOR’
     Synonym for ‘N’.

‘SD’
     Synonym for ‘STDDEV’.

‘N_SCALAR’
     Accepts a single number from the ‘MATRIX DATA’ input and writes it
     as an ‘N’ row with the number replicated across all the continuous
     variables.


File: pspp.info,  Node: MATRIX DATA,  Next: MCONVERT,  Prev: Matrix Files,  Up: Matrices

16.2 MATRIX DATA
================

     MATRIX DATA
             VARIABLES=VARIABLES
             [FILE={’FILE_NAME’ | INLINE}
             [/FORMAT=[{LIST | FREE}]
                      [{UPPER | LOWER | FULL}]
                      [{DIAGONAL | NODIAGONAL}]]
             [/SPLIT=SPLIT_VARS]
             [/FACTORS=FACTOR_VARS]
             [/N=N]

     The following subcommands are only needed when ROWTYPE_ is not
     specified on the VARIABLES subcommand:
             [/CONTENTS={CORR,COUNT,COV,DFE,MAT,MEAN,MSE,
                         N_MATRIX,N|N_VECTOR,N_SCALAR,PROX,SD|STDDEV}]
             [/CELLS=N_CELLS]

   The ‘MATRIX DATA’ command convert matrices and vectors from text
format into the matrix file format (*Note Matrix Files::) for use by
procedures that read matrices.  It reads a text file or inline data and
outputs to the active file, replacing any data already in the active
dataset.  The matrix file may then be used by other commands directly
from the active file, or it may be written to a ‘.sav’ file using the
‘SAVE’ command.

   The text data read by ‘MATRIX DATA’ can be delimited by spaces or
commas.  A plus or minus sign, except immediately following a ‘d’ or
‘e’, also begins a new value.  Optionally, values may be enclosed in
single or double quotes.

   ‘MATRIX DATA’ can read the types of matrix and vector data supported
in matrix files (*note Matrix File Row Types::).

   The ‘FILE’ subcommand specifies the source of the command’s input.
To read input from a text file, specify its name in quotes.  To supply
input inline, omit ‘FILE’ or specify ‘INLINE’.  Inline data must
directly follow ‘MATRIX DATA’, inside ‘BEGIN DATA’ (*note BEGIN DATA::).

   ‘VARIABLES’ is the only required subcommand.  It names the variables
present in each input record in the order that they appear.  (‘MATRIX
DATA’ reorders the variables in the matrix file it produces, if needed
to fit the matrix file format.)  The variable list must include split
variables and factor variables, if they are present in the data, in
addition to the continuous variables that form matrix rows and columns.
It may also include a special variable named ‘ROWTYPE_’.

   Matrix data may include split variables or factor variables or both.
List split variables, if any, on the ‘SPLIT’ subcommand and factor
variables, if any, on the ‘FACTORS’ subcommand.  Split and factor
variables must be numeric.  Split and factor variables must also be
listed on ‘VARIABLES’, with one exception: if ‘VARIABLES’ does not
include ‘ROWTYPE_’, then ‘SPLIT’ may name a single variable that is not
in ‘VARIABLES’ (*note MATRIX DATA Example 8::).

   The ‘FORMAT’ subcommand accepts settings to describe the format of
the input data:

‘LIST’ (default)
‘FREE’
     LIST requires each row to begin at the start of a new input line.
     FREE allows rows to begin in the middle of a line.  Either setting
     allows a single row to continue across multiple input lines.

‘LOWER’ (default)
‘UPPER’
‘FULL’
     With LOWER, only the lower triangle is read from the input data and
     the upper triangle is mirrored across the main diagonal.  UPPER
     behaves similarly for the upper triangle.  FULL reads the entire
     matrix.

‘DIAGONAL’ (default)
‘NODIAGONAL’
     With DIAGONAL, the main diagonal is read from the input data.  With
     NODIAGONAL, which is incompatible with FULL, the main diagonal is
     not read from the input data but instead set to 1 for correlation
     matrices and system-missing for others.

   The ‘N’ subcommand is a way to specify the size of the population.
It is equivalent to specifying an ‘N’ vector with the specified value
for each split file.

   ‘MATRIX DATA’ supports two different ways to indicate the kinds of
matrices and vectors present in the data, depending on whether a
variable with the special name ‘ROWTYPE_’ is present in ‘VARIABLES’.
The following subsections explain ‘MATRIX DATA’ syntax and behavior in
each case.

* Menu:

* MATRIX DATA with ROWTYPE_::
* MATRIX DATA without ROWTYPE_::


File: pspp.info,  Node: MATRIX DATA with ROWTYPE_,  Next: MATRIX DATA without ROWTYPE_,  Up: MATRIX DATA

16.2.1 With ‘ROWTYPE_’
----------------------

If ‘VARIABLES’ includes ‘ROWTYPE_’, each case’s ‘ROWTYPE_’ indicates the
type of data contained in the row.  *Note Matrix File Row Types::, for a
list of supported row types.

Example 1: Defaults with ‘ROWTYPE_’
...................................

This example shows a simple use of ‘MATRIX DATA’ with ‘ROWTYPE_’ plus 8
variables named ‘var01’ through ‘var08’.

   Because ‘ROWTYPE_’ is the first variable in ‘VARIABLES’, it appears
first on each line.  The first three lines in the example data have
‘ROWTYPE_’ values of ‘MEAN’, ‘SD’, and ‘N’.  These indicate that these
lines contain vectors of means, standard deviations, and counts,
respectively, for ‘var01’ through ‘var08’ in order.

   The remaining 8 lines have a ROWTYPE_ of ‘CORR’ which indicates that
the values are correlation coefficients.  Each of the lines corresponds
to a row in the correlation matrix: the first line is for ‘var01’, the
next line for ‘var02’, and so on.  The input only contains values for
the lower triangle, including the diagonal, since ‘FORMAT=LOWER
DIAGONAL’ is the default.

   With ‘ROWTYPE_’, the ‘CONTENTS’ subcommand is optional and the
‘CELLS’ subcommand may not be used.

     MATRIX DATA
         VARIABLES=ROWTYPE_ var01 TO var08.
     BEGIN DATA.
     MEAN  24.3   5.4  69.7  20.1  13.4   2.7  27.9   3.7
     SD     5.7   1.5  23.5   5.8   2.8   4.5   5.4   1.5
     N       92    92    92    92    92    92    92    92
     CORR  1.00
     CORR   .18  1.00
     CORR  -.22  -.17  1.00
     CORR   .36   .31  -.14  1.00
     CORR   .27   .16  -.12   .22  1.00
     CORR   .33   .15  -.17   .24   .21  1.00
     CORR   .50   .29  -.20   .32   .12   .38  1.00
     CORR   .17   .29  -.05   .20   .27   .20   .04  1.00
     END DATA.

Example 2: ‘FORMAT=UPPER NODIAGONAL’
....................................

This syntax produces the same matrix file as example 1, but it uses
‘FORMAT=UPPER NODIAGONAL’ to specify the upper triangle and omit the
diagonal.  Because the matrix’s ‘ROWTYPE_’ is ‘CORR’, PSPP automatically
fills in the diagonal with 1.

     MATRIX DATA
         VARIABLES=ROWTYPE_ var01 TO var08
         /FORMAT=UPPER NODIAGONAL.
     BEGIN DATA.
     MEAN  24.3   5.4  69.7  20.1  13.4   2.7  27.9   3.7
     SD     5.7   1.5  23.5   5.8   2.8   4.5   5.4   1.5
     N       92    92    92    92    92    92    92    92
     CORR         .17   .50  -.33   .27   .36  -.22   .18
     CORR               .29   .29  -.20   .32   .12   .38
     CORR                     .05   .20  -.15   .16   .21
     CORR                           .20   .32  -.17   .12
     CORR                                 .27   .12  -.24
     CORR                                      -.20  -.38
     CORR                                             .04
     END DATA.

Example 3: ‘N’ subcommand
.........................

This syntax uses the ‘N’ subcommand in place of an ‘N’ vector.  It
produces the same matrix file as examples 1 and 2.

     MATRIX DATA
         VARIABLES=ROWTYPE_ var01 TO var08
         /FORMAT=UPPER NODIAGONAL
         /N 92.
     BEGIN DATA.
     MEAN  24.3   5.4  69.7  20.1  13.4   2.7  27.9   3.7
     SD     5.7   1.5  23.5   5.8   2.8   4.5   5.4   1.5
     CORR         .17   .50  -.33   .27   .36  -.22   .18
     CORR               .29   .29  -.20   .32   .12   .38
     CORR                     .05   .20  -.15   .16   .21
     CORR                           .20   .32  -.17   .12
     CORR                                 .27   .12  -.24
     CORR                                      -.20  -.38
     CORR                                             .04
     END DATA.

Example 4: Split variables
..........................

This syntax defines two matrices, using the variable ‘s1’ to distinguish
between them.  Notice how the order of variables in the input matches
their order on ‘VARIABLES’.  This example also uses ‘FORMAT=FULL’.

     MATRIX DATA
         VARIABLES=s1 ROWTYPE_  var01 TO var04
         /SPLIT=s1
         /FORMAT=FULL.
     BEGIN DATA.
     0 MEAN 34 35 36 37
     0 SD   22 11 55 66
     0 N    99 98 99 92
     0 CORR  1 .9 .8 .7
     0 CORR .9  1 .6 .5
     0 CORR .8 .6  1 .4
     0 CORR .7 .5 .4  1
     1 MEAN 44 45 34 39
     1 SD   23 15 51 46
     1 N    98 34 87 23
     1 CORR  1 .2 .3 .4
     1 CORR .2  1 .5 .6
     1 CORR .3 .5  1 .7
     1 CORR .4 .6 .7  1
     END DATA.

Example 5: Factor variables
...........................

This syntax defines a matrix file that includes a factor variable ‘f1’.
The data includes mean, standard deviation, and count vectors for two
values of the factor variable, plus a correlation matrix for pooled
data.

     MATRIX DATA
         VARIABLES=ROWTYPE_ f1 var01 TO var04
         /FACTOR=f1.
     BEGIN DATA.
     MEAN 0 34 35 36 37
     SD   0 22 11 55 66
     N    0 99 98 99 92
     MEAN 1 44 45 34 39
     SD   1 23 15 51 46
     N    1 98 34 87 23
     CORR .  1
     CORR . .9  1
     CORR . .8 .6  1
     CORR . .7 .5 .4  1
     END DATA.


File: pspp.info,  Node: MATRIX DATA without ROWTYPE_,  Prev: MATRIX DATA with ROWTYPE_,  Up: MATRIX DATA

16.2.2 Without ‘ROWTYPE_’
-------------------------

If ‘VARIABLES’ does not contain ‘ROWTYPE_’, the ‘CONTENTS’ subcommand
defines the row types that appear in the file and their order.  If
‘CONTENTS’ is omitted, ‘CONTENTS=CORR’ is assumed.

   Factor variables without ‘ROWTYPE_’ introduce special requirements,
illustrated below in Examples 8 and 9.

Example 6: Defaults without ‘ROWTYPE_’
......................................

This example shows a simple use of ‘MATRIX DATA’ with 8 variables named
‘var01’ through ‘var08’, without ‘ROWTYPE_’.  This yields the same
matrix file as Example 1 (*note MATRIX DATA Example 1::).

     MATRIX DATA
         VARIABLES=var01 TO var08
        /CONTENTS=MEAN SD N CORR.
     BEGIN DATA.
     24.3   5.4  69.7  20.1  13.4   2.7  27.9   3.7
      5.7   1.5  23.5   5.8   2.8   4.5   5.4   1.5
       92    92    92    92    92    92    92    92
     1.00
      .18  1.00
     -.22  -.17  1.00
      .36   .31  -.14  1.00
      .27   .16  -.12   .22  1.00
      .33   .15  -.17   .24   .21  1.00
      .50   .29  -.20   .32   .12   .38  1.00
      .17   .29  -.05   .20   .27   .20   .04  1.00
     END DATA.

Example 7: Split variables with explicit values
...............................................

This syntax defines two matrices, using the variable ‘s1’ to distinguish
between them.  Each line of data begins with ‘s1’.  This yields the same
matrix file as Example 4 (*note MATRIX DATA Example 4::).

     MATRIX DATA
         VARIABLES=s1 var01 TO var04
         /SPLIT=s1
         /FORMAT=FULL
         /CONTENTS=MEAN SD N CORR.
     BEGIN DATA.
     0 34 35 36 37
     0 22 11 55 66
     0 99 98 99 92
     0  1 .9 .8 .7
     0 .9  1 .6 .5
     0 .8 .6  1 .4
     0 .7 .5 .4  1
     1 44 45 34 39
     1 23 15 51 46
     1 98 34 87 23
     1  1 .2 .3 .4
     1 .2  1 .5 .6
     1 .3 .5  1 .7
     1 .4 .6 .7  1
     END DATA.

Example 8: Split variable with sequential values
................................................

Like this previous example, this syntax defines two matrices with split
variable ‘s1’.  In this case, though, ‘s1’ is not listed in ‘VARIABLES’,
which means that its value does not appear in the data.  Instead,
‘MATRIX DATA’ reads matrix data until the input is exhausted, supplying
1 for the first split, 2 for the second, and so on.

     MATRIX DATA
         VARIABLES=var01 TO var04
         /SPLIT=s1
         /FORMAT=FULL
         /CONTENTS=MEAN SD N CORR.
     BEGIN DATA.
     34 35 36 37
     22 11 55 66
     99 98 99 92
      1 .9 .8 .7
     .9  1 .6 .5
     .8 .6  1 .4
     .7 .5 .4  1
     44 45 34 39
     23 15 51 46
     98 34 87 23
      1 .2 .3 .4
     .2  1 .5 .6
     .3 .5  1 .7
     .4 .6 .7  1
     END DATA.

16.2.2.1 Factor variables without ‘ROWTYPE_’
............................................

Without ‘ROWTYPE_’, factor variables introduce two new wrinkles to
‘MATRIX DATA’ syntax.  First, the ‘CELLS’ subcommand must declare the
number of combinations of factor variables present in the data.  If
there is, for example, one factor variable for which the data contains
three values, one would write ‘CELLS=3’; if there are two (or more)
factor variables for which the data contains five combinations, one
would use ‘CELLS=5’; and so on.

   Second, the ‘CONTENTS’ subcommand must distinguish within-cell data
from pooled data by enclosing within-cell row types in parentheses.
When different within-cell row types for a single factor appear in
subsequent lines, enclose the row types in a single set of parentheses;
when different factors’ values for a given within-cell row type appear
in subsequent lines, enclose each row type in individual parentheses.

   Without ‘ROWTYPE_’, input lines for pooled data do not include factor
values, not even as missing values, but input lines for within-cell data
do.

   The following examples aim to clarify this syntax.

Example 9: Factor variables, grouping within-cell records by factor
...................................................................

This syntax defines the same matrix file as Example 5 (*note MATRIX DATA
Example 5::), without using ‘ROWTYPE_’.  It declares ‘CELLS=2’ because
the data contains two values (0 and 1) for factor variable ‘f1’.
Within-cell vector row types ‘MEAN’, ‘SD’, and ‘N’ are in a single set
of parentheses on ‘CONTENTS’ because they are grouped together in
subsequent lines for a single factor value.  The data lines with the
pooled correlation matrix do not have any factor values.

     MATRIX DATA
         VARIABLES=f1 var01 TO var04
         /FACTOR=f1
         /CELLS=2
         /CONTENTS=(MEAN SD N) CORR.
     BEGIN DATA.
     0 34 35 36 37
     0 22 11 55 66
     0 99 98 99 92
     1 44 45 34 39
     1 23 15 51 46
     1 98 34 87 23
        1
       .9  1
       .8 .6  1
       .7 .5 .4  1
     END DATA.

Example 10: Factor variables, grouping within-cell records by row type
......................................................................

This syntax defines the same matrix file as the previous example.  The
only difference is that the within-cell vector rows are grouped
differently: two rows of means (one for each factor), followed by two
rows of standard deviations, followed by two rows of counts.

     MATRIX DATA
         VARIABLES=f1 var01 TO var04
         /FACTOR=f1
         /CELLS=2
         /CONTENTS=(MEAN) (SD) (N) CORR.
     BEGIN DATA.
     0 34 35 36 37
     1 44 45 34 39
     0 22 11 55 66
     1 23 15 51 46
     0 99 98 99 92
     1 98 34 87 23
        1
       .9  1
       .8 .6  1
       .7 .5 .4  1
     END DATA.


File: pspp.info,  Node: MCONVERT,  Next: MATRIX,  Prev: MATRIX DATA,  Up: Matrices

16.3 MCONVERT
=============

     MCONVERT
         [[MATRIX=]
          [IN({‘*’|’FILE’})]
          [OUT({‘*’|’FILE’})]]
         [/{REPLACE,APPEND}].

   The ‘MCONVERT’ command converts matrix data from a correlation matrix
and a vector of standard deviations into a covariance matrix, or vice
versa.

   By default, ‘MCONVERT’ both reads and writes the active file.  Use
the ‘MATRIX’ subcommand to specify other files.  To read a matrix file,
specify its name inside parentheses following ‘IN’.  To write a matrix
file, specify its name inside parentheses following ‘OUT’.  Use ‘*’ to
explicitly specify the active file for input or output.

   When ‘MCONVERT’ reads the input, by default it substitutes a
correlation matrix and a vector of standard deviations each time it
encounters a covariance matrix, and vice versa.  Specify ‘/APPEND’ to
instead have ‘MCONVERT’ add the other form of data without removing the
existing data.  Use ‘/REPLACE’ to explicitly request removing the
existing data.

   The ‘MCONVERT’ command requires its input to be a matrix file.  Use
‘MATRIX DATA’ to convert text input into matrix file format.  *Note
MATRIX DATA::, for details.


File: pspp.info,  Node: MATRIX,  Prev: MCONVERT,  Up: Matrices

16.4 MATRIX
===========

     MATRIX.
     ...matrix commands...
     END MATRIX.

The following basic matrix commands are supported:

     COMPUTE variable[(index[,index])]=expression.
     CALL procedure(argument, ...).
     PRINT [expression]
           [/FORMAT=format]
           [/TITLE=title]
           [/SPACE={NEWPAGE | n}]
           [{/RLABELS=string... | /RNAMES=expression}]
           [{/CLABELS=string... | /CNAMES=expression}].

The following matrix commands offer support for flow control:

     DO IF expression.
       ...matrix commands...
     [ELSE IF expression.
       ...matrix commands...]...
     [ELSE
       ...matrix commands...]
     END IF.

     LOOP [var=first TO last [BY step]] [IF expression].
       ...matrix commands...
     END LOOP [IF expression].

     BREAK.

The following matrix commands support matrix input and output:

     READ variable[(index[,index])]
          [/FILE=file]
          /FIELD=first TO last [BY width]
          [/FORMAT=format]
          [/SIZE=expression]
          [/MODE={RECTANGULAR | SYMMETRIC}]
          [/REREAD].
     WRITE expression
           [/OUTFILE=file]
           /FIELD=first TO last [BY width]
           [/MODE={RECTANGULAR | TRIANGULAR}]
           [/HOLD]
           [/FORMAT=format].
     GET variable[(index[,index])]
         [/FILE={file | *}]
         [/VARIABLES=variable...]
         [/NAMES=expression]
         [/MISSING={ACCEPT | OMIT | number}]
         [/SYSMIS={OMIT | number}].
     SAVE expression
          [/OUTFILE={file | *}]
          [/VARIABLES=variable...]
          [/NAMES=expression]
          [/STRINGS=variable...].
     MGET [/FILE=file]
          [/TYPE={COV | CORR | MEAN | STDDEV | N | COUNT}].
     MSAVE expression
           /TYPE={COV | CORR | MEAN | STDDEV | N | COUNT}
           [/OUTFILE=file]
           [/VARIABLES=variable...]
           [/SNAMES=variable...]
           [/SPLIT=expression]
           [/FNAMES=variable...]
           [/FACTOR=expression].

The following matrix commands provide additional support:

     DISPLAY [{DICTIONARY | STATUS}].
     RELEASE variable....

   ‘MATRIX’ and ‘END MATRIX’ enclose a special PSPP sub-language, called
the matrix language.  The matrix language does not require an active
dataset to be defined and only a few of the matrix language commands
work with any datasets that are defined.  Each instance of
‘MATRIX’...‘END MATRIX’ is a separate program whose state is independent
of any instance, so that variables declared within a matrix program are
forgotten at its end.

   The matrix language works with matrices, where a “matrix” is a
rectangular array of real numbers.  An N×M matrix has N rows and M
columns.  Some special cases are important: a N×1 matrix is a “column
vector”, a 1×N is a “row vector”, and a 1×1 matrix is a “scalar”.

   The matrix language also has limited support for matrices that
contain 8-byte strings instead of numbers.  Strings longer than 8 bytes
are truncated, and shorter strings are padded with spaces.  String
matrices are mainly useful for labeling rows and columns when printing
numerical matrices with the ‘MATRIX PRINT’ command.  Arithmetic
operations on string matrices will not produce useful results.  The user
should not mix strings and numbers within a matrix.

   The matrix language does not work with cases.  A variable in the
matrix language represents a single matrix.

   The matrix language does not support missing values.

   ‘MATRIX’ is a procedure, so it cannot be enclosed inside ‘DO IF’,
‘LOOP’, etc.

   Macros may be used within a matrix program, and macros may expand to
include entire matrix programs.  The ‘DEFINE’ command may not appear
within a matrix program.  *Note DEFINE::, for more information about
macros.

   The following sections describe the details of the matrix language:
first, the syntax of matrix expressions, then each of the supported
commands.  The ‘COMMENT’ command (*note COMMENT::) is also supported.

* Menu:

* Matrix Expressions::
* Matrix Functions::
* Matrix COMPUTE Command::
* Matrix CALL command::
* Matrix PRINT Command::
* Matrix DO IF Command::
* Matrix LOOP and BREAK Commands::
* Matrix READ and WRITE Commands::
* Matrix GET Command::
* Matrix SAVE Command::
* Matrix MGET Command::
* Matrix MSAVE Command::
* Matrix DISPLAY Command::
* Matrix RELEASE Command::


File: pspp.info,  Node: Matrix Expressions,  Next: Matrix Functions,  Up: MATRIX

16.4.1 Matrix Expressions
-------------------------

Many matrix commands use expressions.  A matrix expression may use the
following operators, listed in descending order of operator precedence.
Within a single level, operators associate from left to right.

   • Function call () and matrix construction {}

   • Indexing ()

   • Unary + and -

   • Integer sequence :

   • Exponentiation ** and &**

   • Multiplication * and &*, and division / and &/

   • Addition + and subtraction -

   • Relational < <= = >= > <>

   • Logical NOT

   • Logical AND

   • Logical OR and XOR

   *Note Matrix Functions::, for the available matrix functions.  The
remaining operators are described in more detail below.

   Expressions appear in the matrix language in some contexts where
there would be ambiguity whether ‘/’ is an operator or a separator
between subcommands.  In these contexts, only the operators with higher
precedence than ‘/’ are allowed outside parentheses.  Later sections
call these “restricted expressions”.

* Menu:

* Matrix Construction Operator::
* Matrix Sequence Operator::
* Matrix Index Operator::
* Matrix Unary Operators::
* Matrix Elementwise Binary Operators::
* Matrix Multiplication Operator::
* Matrix Exponentiation Operator::


File: pspp.info,  Node: Matrix Construction Operator,  Next: Matrix Sequence Operator,  Up: Matrix Expressions

16.4.1.1 Matrix Construction Operator {}
........................................

Use the {} operator to construct matrices.  Within the curly braces,
commas separate elements within a row and semicolons separate rows.  The
following examples show a 2×3 matrix, a 1×4 row vector, a 3×1 column
vector, and a scalar.

{1, 2, 3; 4, 5, 6}            ⇒    [1 2 3]
                                   [4 5 6]  
{3.14, 6.28, 9.24, 12.57}     ⇒    [3.14 6.28 9.42 12.57]  
{1.41; 1.73; 2}               ⇒    [1.41]
                                   [1.73]
                                   [2.00]  
{5}                           ⇒    5

   Curly braces are not limited to holding numeric literals.  They can
contain calculations, and they can paste together matrices and vectors
in any way as long as the result is rectangular.  For example, if ‘m’ is
matrix ‘{1, 2; 3, 4}’, ‘r’ is row vector ‘{5, 6}’, and ‘c’ is column
vector ‘{7, 8}’, then curly braces can be used as follows:

{m, c; r, 10}                 ⇒    [1 2 7]
                                   [3 4 8]
                                   [5 6 10]  
{c, 2 * c, T(r)}              ⇒    [7 14 5]
                                   [8 16 6]

   The final example above uses the transposition function ‘T’.


File: pspp.info,  Node: Matrix Sequence Operator,  Next: Matrix Index Operator,  Prev: Matrix Construction Operator,  Up: Matrix Expressions

16.4.1.2 Integer Sequence Operator ‘:’
......................................

The syntax ‘FIRST:LAST:STEP’ yields a row vector of consecutive integers
from FIRST to LAST counting by STEP.  The final ‘:STEP’ is optional and
defaults to 1 when omitted.

   Each of FIRST, LAST, and STEP must be a scalar and should be an
integer (any fractional part is discarded).  Because ‘:’ has a high
precedence, operands other than numeric literals must usually be
parenthesized.

   When STEP is positive (or omitted) and END < START, or if STEP is
negative and END > START, then the result is an empty matrix.  If STEP
is 0, then PSPP reports an error.

   Here are some examples:

1:6                           ⇒    {1, 2, 3, 4, 5, 6}
1:6:2                         ⇒    {1, 3, 5}
-1:-5:-1                      ⇒    {-1, -2, -3, -4, -5}
-1:-5                         ⇒    {}
2:1:0                         ⇒    (error)


File: pspp.info,  Node: Matrix Index Operator,  Next: Matrix Unary Operators,  Prev: Matrix Sequence Operator,  Up: Matrix Expressions

16.4.1.3 Index Operator ‘()’
............................

The result of the submatrix or indexing operator, written ‘M(RINDEX,
CINDEX)’, contains the rows of M whose indexes are given in vector
RINDEX and the columns whose indexes are given in vector CINDEX.

   In the simplest case, if RINDEX and CINDEX are both scalars, the
result is also a scalar:

{10, 20; 30, 40}(1, 1)        ⇒    10
{10, 20; 30, 40}(1, 2)        ⇒    20
{10, 20; 30, 40}(2, 1)        ⇒    30
{10, 20; 30, 40}(2, 2)        ⇒    40

   If the index arguments have multiple elements, then the result
includes multiple rows or columns:

{10, 20; 30, 40}(1:2, 1)      ⇒    {10; 30}
{10, 20; 30, 40}(2, 1:2)      ⇒    {30, 40}
{10, 20; 30, 40}(1:2, 1:2)    ⇒    {10, 20; 30, 40}

   The special argument ‘:’ may stand in for all the rows or columns in
the matrix being indexed, like this:

{10, 20; 30, 40}(:, 1)        ⇒    {10; 30}
{10, 20; 30, 40}(2, :)        ⇒    {30, 40}
{10, 20; 30, 40}(:, :)        ⇒    {10, 20; 30, 40}

   The index arguments do not have to be in order, and they may contain
repeated values, like this:

{10, 20; 30, 40}({2, 1}, 1)   ⇒    {30; 10}
{10, 20; 30, 40}(2, {2; 2;    ⇒    {40, 40, 30}
1})
{10, 20; 30, 40}(2:1:-1, :)   ⇒    {30, 40; 10, 20}

   When the matrix being indexed is a row or column vector, only a
single index argument is needed, like this:

{11, 12, 13, 14, 15}(2:4)     ⇒    {12, 13, 14}
{11; 12; 13; 14; 15}(2:4)     ⇒    {12; 13; 14}

   When an index is not an integer, PSPP discards the fractional part.
It is an error for an index to be less than 1 or greater than the number
of rows or columns:

{11, 12, 13, 14}({2.5,        ⇒    {12, 14}
4.6})
{11; 12; 13; 14}(0)           ⇒    (error)


File: pspp.info,  Node: Matrix Unary Operators,  Next: Matrix Elementwise Binary Operators,  Prev: Matrix Index Operator,  Up: Matrix Expressions

16.4.1.4 Unary Operators
........................

The unary operators take a single operand of any dimensions and operate
on each of its elements independently.  The unary operators are:

‘-’
     Inverts the sign of each element.

‘+’
     No change.

‘NOT’
     Logical inversion: each positive value becomes 0 and each zero or
     negative value becomes 1.

   Examples:

-{1, -2; 3, -4}               ⇒    {-1, 2; -3, 4}
+{1, -2; 3, -4}               ⇒    {1, -2; 3, -4}
NOT {1, 0; -1, 1}             ⇒    {0, 1; 1, 0}


File: pspp.info,  Node: Matrix Elementwise Binary Operators,  Next: Matrix Multiplication Operator,  Prev: Matrix Unary Operators,  Up: Matrix Expressions

16.4.1.5 Elementwise Binary Operators
.....................................

The elementwise binary operators require their operands to be matrices
with the same dimensions.  Alternatively, if one operand is a scalar,
then its value is treated as if it were duplicated to the dimensions of
the other operand.  The result is a matrix of the same size as the
operands, in which each element is the result of the applying the
operator to the corresponding elements of the operands.

   The elementwise binary operators are listed below.

   • The arithmetic operators, for familiar arithmetic operations:

     ‘+’
          Addition.

     ‘-’
          Subtraction.

     ‘*’
          Multiplication, if one operand is a scalar.  (Otherwise this
          is matrix multiplication, described below.)

     ‘/’ or ‘&/’
          Division.

     ‘&*’
          Multiplication.

     ‘&**’
          Exponentiation.

   • The relational operators, whose results are 1 when a comparison is
     true and 0 when it is false:

     ‘<’ or ‘LT’
          Less than.

     ‘<=’ or ‘LE’
          Less than or equal.

     ‘=’ or ‘EQ’
          Equal.

     ‘>’ or ‘GT’
          Greater than.

     ‘>=’ or ‘GE’
          Greater than or equal.

     ‘<>’ or ‘~=’ or ‘NE’
          Not equal.

   • The logical operators, which treat positive operands as true and
     nonpositive operands as false.  They yield 0 for false and 1 for
     true:

     ‘AND’
          True if both operands are true.

     ‘OR’
          True if at least one operand is true.

     ‘XOR’
          True if exactly one operand is true.

   Examples:

1 + 2                         ⇒    3
1 + {3; 4}                    ⇒    {4; 5}
{66, 77; 88, 99} + 5          ⇒    {71, 82; 93, 104}
{4, 8; 3, 7} + {1, 0; 5, 2}   ⇒    {5, 8; 8, 9}
{1, 2; 3, 4} < {4, 3; 2, 1}   ⇒    {1, 1; 0, 0}
{1, 3; 2, 4} >= 3             ⇒    {0, 1; 0, 1}
{0, 0; 1, 1} AND {0, 1; 0,    ⇒    {0, 0; 0, 1}
1}


File: pspp.info,  Node: Matrix Multiplication Operator,  Next: Matrix Exponentiation Operator,  Prev: Matrix Elementwise Binary Operators,  Up: Matrix Expressions

16.4.1.6 Matrix Multiplication Operator ‘*’
...........................................

If ‘A’ is an M×N matrix and ‘B’ is an N×P matrix, then ‘A*B’ is the M×P
matrix multiplication product ‘C’.  PSPP reports an error if the number
of columns in ‘A’ differs from the number of rows in ‘B’.

   The ‘*’ operator performs elementwise multiplication (see above) if
one of its operands is a scalar.

   No built-in operator yields the inverse of matrix multiplication.
Instead, multiply by the result of ‘INV’ or ‘GINV’.

   Some examples:

{1, 2, 3} * {4; 5; 6}         ⇒    32
{4; 5; 6} * {1, 2, 3}         ⇒    {4,  8, 12;
                                    5, 10, 15;
                                    6, 12, 18}


File: pspp.info,  Node: Matrix Exponentiation Operator,  Prev: Matrix Multiplication Operator,  Up: Matrix Expressions

16.4.1.7 Matrix Exponentiation Operator ‘**’
............................................

The result of ‘A**B’ is defined as follows when ‘A’ is a square matrix
and ‘B’ is an integer scalar:

   • For ‘B > 0’, ‘A**B’ is ‘A*...*A’, where there are ‘B’ ‘A’s.  (PSPP
     implements this efficiently for large ‘B’, using exponentiation by
     squaring.)

   • For ‘B < 0’, ‘A**B’ is ‘INV(A**(-B))’.

   • For ‘B = 0’, ‘A**B’ is the identity matrix.

PSPP reports an error if ‘A’ is not square or ‘B’ is not an integer.

   Examples:

{2, 5; 1, 4}**3               ⇒    {48, 165; 33, 114}
{2, 5; 1, 4}**0               ⇒    {1, 0; 0, 1}
10*{4, 7; 2, 6}**-1           ⇒    {6, -7; -2, 4}


File: pspp.info,  Node: Matrix Functions,  Next: Matrix COMPUTE Command,  Prev: Matrix Expressions,  Up: MATRIX

16.4.2 Matrix Functions
-----------------------

The matrix language support numerous functions in multiple categories.
The following subsections document each of the currently supported
functions.  The first letter of each parameter’s name indicate the
required argument type:

S
     A scalar.

N
     A nonnegative integer scalar.  (Non-integers are accepted and
     silently rounded down to the nearest integer.)

V
     A row or column vector.

M
     A matrix.

* Menu:

* Matrix Elementwise Functions::
* Matrix Logical Functions::
* Matrix Construction Functions::
* Matrix Minimum and Maximum and Sum Functions::
* Matrix Property Functions::
* Matrix Rank Ordering Functions::
* Matrix Algebra Functions::
* Matrix Statistical Distribution Functions::
* Matrix EOF Function::


File: pspp.info,  Node: Matrix Elementwise Functions,  Next: Matrix Logical Functions,  Up: Matrix Functions

16.4.2.1 Elementwise Functions
..............................

These functions act on each element of their argument independently,
like the elementwise operators (*note Matrix Elementwise Binary
Operators::).

 -- Matrix Function: ABS (M)
     Takes the absolute value of each element of M.

     ABS({-1, 2; -3, 0}) ⇒ {1, 2; 3, 0}

 -- Matrix Function: ARSIN (M)
 -- Matrix Function: ARTAN (M)
     Computes the inverse sine or tangent, respectively, of each element
     in M.  The results are in radians, between -\pi/2 and +\pi/2,
     inclusive.

     The value of \pi can be computed as ‘4*ARTAN(1)’.

     ARSIN({-1, 0, 1}) ⇒ {-1.57, 0, 1.57} (approximately)

     ARTAN({-5, -1, 1, 5}) ⇒ {-1.37, -.79, .79, 1.37} (approximately)

 -- Matrix Function: COS (M)
 -- Matrix Function: SIN (M)
     Computes the cosine or sine, respectively, of each element in M,
     which must be in radians.

     COS({0.785, 1.57; 3.14, 1.57 + 3.14}) ⇒ {.71, 0; -1, 0}
     (approximately)

 -- Matrix Function: EXP (M)
     Computes e^x for each element X in M.

     EXP({2, 3; 4, 5}) ⇒ {7.39, 20.09; 54.6, 148.4} (approximately)

 -- Matrix Function: LG10 (M)
 -- Matrix Function: LN (M)
     Takes the logarithm with base 10 or base e, respectively, of each
     element in M.

     LG10({1, 10, 100, 1000}) ⇒ {0, 1, 2, 3}
     LG10(0) ⇒ (error)

     LN({EXP(1), 1, 2, 3, 4}) ⇒ {1, 0, .69, 1.1, 1.39} (approximately)
     LN(0) ⇒ (error)

 -- Matrix Function: MOD (M, S)
     Takes each element in M modulo nonzero scalar value S, that is, the
     remainder of division by S.  The sign of the result is the same as
     the sign of the dividend.

     MOD({5, 4, 3, 2, 1, 0}, 3) ⇒ {2, 1, 0, 2, 1, 0}
     MOD({5, 4, 3, 2, 1, 0}, -3) ⇒ {2, 1, 0, 2, 1, 0}
     MOD({-5, -4, -3, -2, -1, 0}, 3) ⇒ {-2, -1, 0, -2, -1, 0}
     MOD({-5, -4, -3, -2, -1, 0}, -3) ⇒ {-2, -1, 0, -2, -1, 0}
     MOD({5, 4, 3, 2, 1, 0}, 1.5) ⇒ {.5, 1.0, .0, .5, 1.0, .0}
     MOD({5, 4, 3, 2, 1, 0}, 0) ⇒ (error)

 -- Matrix Function: RND (M)
 -- Matrix Function: TRUNC (M)
     Rounds each element of M to an integer.  ‘RND’ rounds to the
     nearest integer, with halves rounded to even integers, and ‘TRUNC’
     rounds toward zero.

     RND({-1.6, -1.5, -1.4}) ⇒ {-2, -2, -1}
     RND({-.6, -.5, -.4}) ⇒ {-1, 0, 0}
     RND({.4, .5, .6} ⇒ {0, 0, 1}
     RND({1.4, 1.5, 1.6}) ⇒ {1, 2, 2}

     TRUNC({-1.6, -1.5, -1.4}) ⇒ {-1, -1, -1}
     TRUNC({-.6, -.5, -.4}) ⇒ {0, 0, 0}
     TRUNC({.4, .5, .6} ⇒ {0, 0, 0}
     TRUNC({1.4, 1.5, 1.6}) ⇒ {1, 1, 1}

 -- Matrix Function: SQRT (M)
     Takes the square root of each element of M, which must not be
     negative.

     SQRT({0, 1, 2, 4, 9, 81}) ⇒ {0, 1, 1.41, 2, 3, 9} (approximately)
     SQRT(-1) ⇒ (error)


File: pspp.info,  Node: Matrix Logical Functions,  Next: Matrix Construction Functions,  Prev: Matrix Elementwise Functions,  Up: Matrix Functions

16.4.2.2 Logical Functions
..........................

 -- Matrix Function: ALL (M)
     Returns a scalar with value 1 if all of the elements in M are
     nonzero, or 0 if at least one element is zero.

     ALL({1, 2, 3} < {2, 3, 4}) ⇒ 1
     ALL({2, 2, 3} < {2, 3, 4}) ⇒ 0
     ALL({2, 3, 3} < {2, 3, 4}) ⇒ 0
     ALL({2, 3, 4} < {2, 3, 4}) ⇒ 0

 -- Matrix Function: ANY (M)
     Returns a scalar with value 1 if any of the elements in M is
     nonzero, or 0 if all of them are zero.

     ANY({1, 2, 3} < {2, 3, 4}) ⇒ 1
     ANY({2, 2, 3} < {2, 3, 4}) ⇒ 1
     ANY({2, 3, 3} < {2, 3, 4}) ⇒ 1
     ANY({2, 3, 4} < {2, 3, 4}) ⇒ 0


File: pspp.info,  Node: Matrix Construction Functions,  Next: Matrix Minimum and Maximum and Sum Functions,  Prev: Matrix Logical Functions,  Up: Matrix Functions

16.4.2.3 Matrix Construction Functions
......................................

 -- Matrix Function: BLOCK (M1, ..., MN)
     Returns a block diagonal matrix with as many rows as the sum of its
     arguments’ row counts and as many columns as the sum of their
     columns.  Each argument matrix is placed along the main diagonal of
     the result, and all other elements are zero.

     BLOCK({1, 2; 3, 4}, 5, {7; 8; 9}, {10, 11}) ⇒
        1   2   0   0   0   0
        3   4   0   0   0   0
        0   0   5   0   0   0
        0   0   0   7   0   0
        0   0   0   8   0   0
        0   0   0   9   0   0
        0   0   0   0  10  11

 -- Matrix Function: IDENT (N)
 -- Matrix Function: IDENT (NR, NC)
     Returns an identity matrix, whose main diagonal elements are one
     and whose other elements are zero.  The returned matrix has N rows
     and columns or NR rows and NC columns, respectively.

     IDENT(1) ⇒ 1
     IDENT(2) ⇒
       1  0
       0  1
     IDENT(3, 5) ⇒
       1  0  0  0  0
       0  1  0  0  0
       0  0  1  0  0
     IDENT(5, 3) ⇒
       1  0  0
       0  1  0
       0  0  1
       0  0  0
       0  0  0

 -- Matrix Function: MAGIC (N)
     Returns an N×N matrix that contains each of the integers 1...N
     once, in which each column, each row, and each diagonal sums to
     n(n^2+1)/2.  There are many magic squares with given dimensions,
     but this function always returns the same one for a given value of
     N.

     MAGIC(3) ⇒ {8, 1, 6; 3, 5, 7; 4, 9, 2}
     MAGIC(4) ⇒ {1, 5, 12, 16; 15, 11, 6, 2; 14, 8, 9, 3; 4, 10, 7, 13}

 -- Matrix Function: MAKE (NR, NC, S)
     Returns an NR×NC matrix whose elements are all S.

     MAKE(1, 2, 3) ⇒ {3, 3}
     MAKE(2, 1, 4) ⇒ {4; 4}
     MAKE(2, 3, 5) ⇒ {5, 5, 5; 5, 5, 5}

 -- Matrix Function: MDIAG (V)
     Given N-element vector V, returns a N×N matrix whose main diagonal
     is copied from V.  The other elements in the returned vector are
     zero.

     Use ‘CALL SETDIAG’ (*note CALL SETDIAG::) to replace the main
     diagonal of a matrix in-place.

     MDIAG({1, 2, 3, 4}) ⇒
       1  0  0  0
       0  2  0  0
       0  0  3  0
       0  0  0  4

 -- Matrix Function: RESHAPE (M, NR, NC)
     Returns an NR×NC matrix whose elements come from M, which must have
     the same number of elements as the new matrix, copying elements
     from M to the new matrix row by row.

     RESHAPE(1:12, 1, 12) ⇒
        1   2   3   4   5   6   7   8   9  10  11  12
     RESHAPE(1:12, 2, 6) ⇒
        1   2   3   4   5   6
        7   8   9  10  11  12
     RESHAPE(1:12, 3, 4) ⇒
        1   2   3   4
        5   6   7   8
        9  10  11  12
     RESHAPE(1:12, 4, 3) ⇒
        1   2   3
        4   5   6
        7   8   9
       10  11  12

 -- Matrix Function: T (M)
 -- Matrix Function: TRANSPOS (M)
     Returns M with rows exchanged for columns.

     T({1, 2, 3}) ⇒ {1; 2; 3}
     T({1; 2; 3}) ⇒ {1, 2, 3}

 -- Matrix Function: UNIFORM (NR, NC)
     Returns a NR×NC matrix in which each element is randomly chosen
     from a uniform distribution of real numbers between 0 and 1.
     Random number generation honors the current seed setting (*note SET
     SEED::).

     The following example shows one possible output, but of course
     every result will be different (given different seeds):

     UNIFORM(4, 5)*10 ⇒
       7.71  2.99   .21  4.95  6.34
       4.43  7.49  8.32  4.99  5.83
       2.25   .25  1.98  7.09  7.61
       2.66  1.69  2.64   .88  1.50


File: pspp.info,  Node: Matrix Minimum and Maximum and Sum Functions,  Next: Matrix Property Functions,  Prev: Matrix Construction Functions,  Up: Matrix Functions

16.4.2.4 Minimum, Maximum, and Sum Functions
............................................

 -- Matrix Function: CMIN (M)
 -- Matrix Function: CMAX (M)
 -- Matrix Function: CSUM (M)
 -- Matrix Function: CSSQ (M)
     Returns a row vector with the same number of columns as M, in which
     each element is the minimum, maximum, sum, or sum of squares,
     respectively, of the elements in the same column of M.

     CMIN({1, 2, 3; 4, 5, 6; 7, 8, 9} ⇒ {1, 2, 3}
     CMAX({1, 2, 3; 4, 5, 6; 7, 8, 9} ⇒ {7, 8, 9}
     CSUM({1, 2, 3; 4, 5, 6; 7, 8, 9} ⇒ {12, 15, 18}
     CSSQ({1, 2, 3; 4, 5, 6; 7, 8, 9} ⇒ {66, 93, 126}

 -- Matrix Function: MMIN (M)
 -- Matrix Function: MMAX (M)
 -- Matrix Function: MSUM (M)
 -- Matrix Function: MSSQ (M)
     Returns the minimum, maximum, sum, or sum of squares, respectively,
     of the elements of M.

     MMIN({1, 2, 3; 4, 5, 6; 7, 8, 9} ⇒ 1
     MMAX({1, 2, 3; 4, 5, 6; 7, 8, 9} ⇒ 9
     MSUM({1, 2, 3; 4, 5, 6; 7, 8, 9} ⇒ 45
     MSSQ({1, 2, 3; 4, 5, 6; 7, 8, 9} ⇒ 285

 -- Matrix Function: RMIN (M)
 -- Matrix Function: RMAX (M)
 -- Matrix Function: RSUM (M)
 -- Matrix Function: RSSQ (M)
     Returns a column vector with the same number of rows as M, in which
     each element is the minimum, maximum, sum, or sum of squares,
     respectively, of the elements in the same row of M.

     RMIN({1, 2, 3; 4, 5, 6; 7, 8, 9} ⇒ {1; 4; 7}
     RMAX({1, 2, 3; 4, 5, 6; 7, 8, 9} ⇒ {3; 6; 9}
     RSUM({1, 2, 3; 4, 5, 6; 7, 8, 9} ⇒ {6; 15; 24}
     RSSQ({1, 2, 3; 4, 5, 6; 7, 8, 9} ⇒ {14; 77; 194}

 -- Matrix Function: SSCP (M)
     Returns M^T × M.

     SSCP({1, 2, 3; 4, 5, 6}) ⇒ {17, 22, 27; 22, 29, 36; 27, 36, 45}

 -- Matrix Function: TRACE (M)
     Returns the sum of the elements along M’s main diagonal, equivalent
     to ‘MSUM(DIAG(M))’.

     TRACE(MDIAG(1:5)) ⇒ 15


File: pspp.info,  Node: Matrix Property Functions,  Next: Matrix Rank Ordering Functions,  Prev: Matrix Minimum and Maximum and Sum Functions,  Up: Matrix Functions

16.4.2.5 Matrix Property Functions
..................................

 -- Matrix Function: NROW (M)
 -- Matrix Function: NCOL (M)
     Returns the number of row or columns, respectively, in M.

     NROW({1, 0; -2, -3; 3, 3}) ⇒ 3
     NROW(1:5) ⇒ 1

     NCOL({1, 0; -2, -3; 3, 3}) ⇒ 2
     NCOL(1:5) ⇒ 5

 -- Matrix Function: DIAG (M)
     Returns a column vector containing a copy of M’s main diagonal.
     The vector’s length is the lesser of ‘NCOL(M)’ and ‘NROW(M)’.

     DIAG({1, 0; -2, -3; 3, 3}) ⇒ {1; -3}


File: pspp.info,  Node: Matrix Rank Ordering Functions,  Next: Matrix Algebra Functions,  Prev: Matrix Property Functions,  Up: Matrix Functions

16.4.2.6 Matrix Rank Ordering Functions
.......................................

The ‘GRADE’ and ‘RANK’ functions each take a matrix M and return a
matrix R with the same dimensions.  Each element in R ranges between 1
and the number of elements N in M, inclusive.  When the elements in M
all have unique values, both of these functions yield the same results:
the smallest element in M corresponds to value 1 in R, the next smallest
to 2, and so on, up to the largest to N.  When multiple elements in M
have the same value, these functions use different rules for handling
the ties.

 -- Matrix Function: GRADE (M)
     Returns a ranking of M, turning duplicate values into sequential
     ranks.  The returned matrix always contains each of the integers 1
     through the number of elements in the matrix exactly once.

     GRADE({1, 0, 3; 3, 1, 2; 3, 0, 5}) ⇒ {3, 1, 6; 7, 4, 5; 8, 2, 9}

 -- Matrix Function: RNKORDER (M)
     Returns a ranking of M, turning duplicate values into the mean of
     their sequential ranks.

     RNKORDER({1, 0, 3; 3, 1, 2; 3, 0, 5})
      ⇒ {3.5, 1.5, 7; 7, 3.5, 5; 7, 1.5, 9}

One may use ‘GRADE’ to sort a vector:

     COMPUTE v(GRADE(v))=v.   /* Sort v in ascending order.
     COMPUTE v(GRADE(-v))=v.  /* Sort v in descending order.


File: pspp.info,  Node: Matrix Algebra Functions,  Next: Matrix Statistical Distribution Functions,  Prev: Matrix Rank Ordering Functions,  Up: Matrix Functions

16.4.2.7 Matrix Algebra Functions
.................................

 -- Matrix Function: CHOL (M)
     Matrix M must be an N×N symmetric positive-definite matrix.
     Returns an N×N matrix B such that B^T×B=M.

     CHOL({4, 12, -16; 12, 37, -43; -16, -43, 98}) ⇒
       2  6 -8
       0  1  5
       0  0  3

 -- Matrix Function: DESIGN (M)
     Returns a design matrix for M.  The design matrix has the same
     number of rows as M.  Each column C in M, from left to right,
     yields a group of columns in the output.  For each unique value V
     in C, from top to bottom, add a column to the output in which V
     becomes 1 and other values become 0.

     PSPP issues a warning if a column only contains a single unique
     value.

     DESIGN({1; 2; 3}) ⇒ {1, 0, 0; 0, 1, 0; 0, 0, 1}
     DESIGN({5; 8; 5}) ⇒ {1, 0; 0, 1; 1, 0}
     DESIGN({1, 5; 2, 8; 3, 5})
      ⇒ {1, 0, 0, 1, 0; 0, 1, 0, 0, 1; 0, 0, 1, 1, 0}
     DESIGN({5; 5; 5}) ⇒ (warning)

 -- Matrix Function: DET (M)
     Returns the determinant of square matrix M.

     DET({3, 7; 1, -4}) ⇒ -19

 -- Matrix Function: EVAL (M)
     Returns a column vector containing the eigenvalues of symmetric
     matrix M, sorted in ascending order.

     Use ‘CALL EIGEN’ (*note CALL EIGEN::) to compute eigenvalues and
     eigenvectors of a matrix.

     EVAL({2, 0, 0; 0, 3, 4; 0, 4, 9}) ⇒ {11; 2; 1}

 -- Matrix Function: GINV (M)
     Returns the K×N matrix A that is the “generalized inverse” of N×K
     matrix M, defined such that M×A×M=M and A×M×A=A.

     GINV({1, 2}) ⇒ {.2; .4} (approximately)
     {1:9} * GINV(1:9) * {1:9} ⇒ {1:9} (approximately)

 -- Matrix Function: GSCH (M)
     M must be a N×M matrix, M ≥ N, with rank N.  Returns an N×N
     orthonormal basis for M, obtained using the Gram-Schmidt process.

     GSCH({3, 2; 1, 2}) * SQRT(10) ⇒ {3, -1; 1, 3} (approximately)

 -- Matrix Function: INV (M)
     Returns the N×N matrix A that is the inverse of N×N matrix M,
     defined such that M×A = A×M = I, where I is the identity matrix.  M
     must not be singular, that is, \det(M) ≠ 0.

     INV({4, 7; 2, 6}) ⇒ {.6, -.7; -.2, .4} (approximately)

 -- Matrix Function: KRONEKER (MA, MB)
     Returns the PM×QN matrix P that is the “Kroneker product” of M×N
     matrix MA and P×Q matrix MB.  One may view P as the concatenation
     of multiple P×Q blocks, each of which is the scalar product of MB
     by a different element of MA.  For example, when ‘A’ is a 2×2
     matrix, ‘KRONEKER(A, B)’ is equivalent to ‘{A(1,1)*B, A(1,2)*B;
     A(2,1)*B, A(2,2)*B}’.

     KRONEKER({1, 2; 3, 4}, {0, 5; 6, 7}) ⇒
        0   5   0  10
        6   7  12  14
        0  15   0  20
       18  21  24  28

 -- Matrix Function: RANK (M)
     Returns the rank of matrix M, an integer scalar whose value is the
     dimension of the vector space spanned by its columns or,
     equivalently, by its rows.

     RANK({1, 0, 1; -2, -3, 1; 3, 3, 0}) ⇒ 2
     RANK({1, 1, 0, 2; -1, -1, 0, -2}) ⇒ 1
     RANK({1, -1; 1, -1; 0, 0; 2, -2}) ⇒ 1
     RANK({1, 2, 1; -2, -3, 1; 3, 5, 0}) ⇒ 2
     RANK({1, 0, 2; 2, 1, 0; 3, 2, 1}) ⇒ 3

 -- Matrix Function: SOLVE (MA, MB)
     MA must be an N×N matrix, with \det(MA) ≠ 0, and MB an N×K matrix.
     Returns an N×K matrix X such that MA × X = MB.

     All of the following examples show approximate results:

     SOLVE({2, 3; 4, 9}, {6, 2; 15, 5}) ⇒
        1.50    .50
        1.00    .33
     SOLVE({1, 3, -2; 3, 5, 6; 2, 4, 3}, {5; 7; 8}) ⇒
      -15.00
        8.00
        2.00
     SOLVE({2, 1, -1; -3, -1, 2; -2, 1, 2}, {8; -11; -3}) ⇒
        2.00
        3.00
       -1.00

 -- Matrix Function: SVAL (M)

     Given N×K matrix M, returns a \min(N,K)-element column vector
     containing the singular values of M in descending order.

     Use ‘CALL SVD’ (*note CALL SVD::) to compute the full singular
     value decomposition of a matrix.

     SVAL({1, 1; 0, 0}) ⇒ {1.41; .00}
     SVAL({1, 0, 1; 0, 1, 1; 0, 0, 0}) ⇒ {1.73; 1.00; .00}
     SVAL({2, 4; 1, 3; 0, 0; 0, 0}) ⇒ {5.46; .37}

 -- Matrix Function: SWEEP (M, NK)
     Given R×C matrix M and integer scalar k = NK such that 1 ≤ k ≤
     \min(R,C), returns the R×C sweep matrix A.

     If M_{kk} ≠ 0, then:

          A_{kk} = 1/M_{kk},
          A_{ik} = -M_{ik}/M_{kk} for i ≠ k,
          A_{kj} = M_{kj}/M_{kk} for j ≠ k, and
          A_{ij} = M_{ij} - M_{ik}M_{kj}/M_{kk} for i ≠ k and j ≠ k.

     If M_{kk} = 0, then:

          A_{ik} = A_{ki} = 0 and
          A_{ij} = M_{ij}, for i ≠ k and j ≠ k.

     Given M = {0, 1, 2; 3, 4, 5; 6, 7, 8}, then (approximately):

     SWEEP(M, 1) ⇒
        .00   .00   .00
        .00  4.00  5.00
        .00  7.00  8.00
     SWEEP(M, 2) ⇒
       -.75  -.25   .75
        .75   .25  1.25
        .75 -1.75  -.75
     SWEEP(M, 3) ⇒
      -1.50  -.75  -.25
       -.75  -.38  -.63
        .75   .88   .13


File: pspp.info,  Node: Matrix Statistical Distribution Functions,  Next: Matrix EOF Function,  Prev: Matrix Algebra Functions,  Up: Matrix Functions

16.4.2.8 Matrix Statistical Distribution Functions
..................................................

The matrix language can calculate several functions of standard
statistical distributions using the same syntax and semantics as in PSPP
transformation expressions.  *Note Statistical Distribution Functions::,
for details.

   The matrix language extends the PDF, CDF, SIG, IDF, NPDF, and NCDF
functions by allowing the first parameters to each of these functions to
be a vector or matrix with any dimensions.  In addition, ‘CDF.BVNOR’ and
‘PDF.BVNOR’ allow either or both of their first two parameters to be
vectors or matrices; if both are non-scalar then they must have the same
dimensions.  In each case, the result is a matrix or vector with the
same dimensions as the input populated with elementwise calculations.


File: pspp.info,  Node: Matrix EOF Function,  Prev: Matrix Statistical Distribution Functions,  Up: Matrix Functions

16.4.2.9 EOF Function
.....................

This function works with files being used on the ‘READ’ statement.

 -- Matrix Function: EOF (FILE)

     Given a file handle or file name FILE, returns an integer scalar 1
     if the last line in the file has been read or 0 if more lines are
     available.  Determining this requires attempting to read another
     line, which means that ‘REREAD’ on the next ‘READ’ command
     following ‘EOF’ on the same file will be ineffective.

   The ‘EOF’ function gives a matrix program the flexibility to read a
file with text data without knowing the length of the file in advance.
For example, the following program will read all the lines of data in
‘data.txt’, each consisting of three numbers, as rows in matrix ‘data’:

MATRIX.
COMPUTE data={}.
LOOP IF NOT EOF('data.txt').
  READ row/FILE='data.txt'/FIELD=1 TO 1000/SIZE={1,3}.
  COMPUTE data={data; row}.
END LOOP.
PRINT data.
END MATRIX.



File: pspp.info,  Node: Matrix COMPUTE Command,  Next: Matrix CALL command,  Prev: Matrix Functions,  Up: MATRIX

16.4.3 The ‘COMPUTE’ Command
----------------------------

     COMPUTE variable[(index[,index])]=expression.

   The ‘COMPUTE’ command evaluates an expression and assigns the result
to a variable or a submatrix of a variable.  Assigning to a submatrix
uses the same syntax as the index operator (*note Matrix Index
Operator::).


File: pspp.info,  Node: Matrix CALL command,  Next: Matrix PRINT Command,  Prev: Matrix COMPUTE Command,  Up: MATRIX

16.4.4 The ‘CALL’ Command
-------------------------

A matrix function returns a single result.  The ‘CALL’ command
implements procedures, which take a similar syntactic form to functions
but yield results by modifying their arguments rather than returning a
value.

   Output arguments to a ‘CALL’ procedure must be a single variable
name.

   The following procedures are implemented via ‘CALL’ to allow them to
return multiple results.  For these procedures, the output arguments
need not name existing variables; if they do, then their previous values
are replaced:

CALL EIGEN(M, EVEC, EVAL)

     Computes the eigenvalues and eigenvector of symmetric N×N matrix M.
     Assigns the eigenvectors of M to the columns of N×N matrix EVEC and
     the eigenvalues in descending order to N-element column vector
     EVAL.

     Use the ‘EVAL’ function (*note EVAL::) to compute just the
     eigenvalues of a symmetric matrix.

     For example, the following matrix language commands:
          CALL EIGEN({1, 0; 0, 1}, evec, eval).
          PRINT evec.
          PRINT eval.

          CALL EIGEN({3, 2, 4; 2, 0, 2; 4, 2, 3}, evec2, eval2).
          PRINT evec2.
          PRINT eval2.

     yield this output:

          evec
            1  0
            0  1

          eval
            1
            1

          evec2
            -.6666666667   .0000000000   .7453559925
            -.3333333333  -.8944271910  -.2981423970
            -.6666666667   .4472135955  -.5962847940

          eval2
            8.0000000000
           -1.0000000000
           -1.0000000000

CALL SVD(M, U, S, V)

     Computes the singular value decomposition of N×K matrix M,
     assigning S a N×K diagonal matrix and to U and V unitary K×K
     matrices such that M = U×S×V^T. The main diagonal of Q contains the
     singular values of M.

     Use the ‘SVAL’ function (*note SVAL::) to compute just the singular
     values of a matrix.

     For example, the following matrix program:

          CALL SVD({3, 2, 2; 2, 3, -2}, u, s, v).
          PRINT (u * s * T(v))/FORMAT F5.1.

     yields this output:

          (u * s * T(v))
             3.0   2.0   2.0
             2.0   3.0  -2.0

   The final procedure is implemented via ‘CALL’ to allow it to modify a
matrix instead of returning a modified version.  For this procedure, the
output argument must name an existing variable.

CALL SETDIAG(M, V)

     Replaces the main diagonal of N×P matrix M by the contents of
     K-element vector V.  If K = 1, so that V is a scalar, replaces all
     of the diagonal elements of M by V.  If K < \min(N,P), only the
     upper K diagonal elements are replaced; if K > \min(N,P), then the
     extra elements of V are ignored.

     Use the ‘MDIAG’ function (*note MDIAG::) to construct a new matrix
     with a specified main diagonal.

     For example, this matrix program:

          COMPUTE x={1, 2, 3; 4, 5, 6; 7, 8, 9}.
          CALL SETDIAG(x, 10).
          PRINT x.

     outputs the following:

          x
            10   2   3
             4  10   6
             7   8  10


File: pspp.info,  Node: Matrix PRINT Command,  Next: Matrix DO IF Command,  Prev: Matrix CALL command,  Up: MATRIX

16.4.5 The ‘PRINT’ Command
--------------------------

     PRINT [expression]
           [/FORMAT=format]
           [/TITLE=title]
           [/SPACE={NEWPAGE | n}]
           [{/RLABELS=string... | /RNAMES=expression}]
           [{/CLABELS=string... | /CNAMES=expression}].

   The ‘PRINT’ command is commonly used to display a matrix.  It
evaluates the restricted EXPRESSION, if present, and outputs it either
as text or a pivot table, depending on the setting of ‘MDISPLAY’ (*note
SET MDISPLAY::).

   Use the ‘FORMAT’ subcommand to specify a format, such as ‘F8.2’, for
displaying the matrix elements.  ‘FORMAT’ is optional for numerical
matrices.  When it is omitted, PSPP chooses how to format entries
automatically using M, the magnitude of the largest-magnitude element in
the matrix to be displayed:

  1. If M < 10^{11} and the matrix’s elements are all integers, PSPP
     chooses the narrowest ‘F’ format that fits M plus a sign.  For
     example, if the matrix is {1:10}, then m = 10, which fits in 3
     columns with room for a sign, the format is ‘F3.0’.

  2. Otherwise, if M ≥ 10^9 or M ≤ 10^{-4}, PSPP scales all of the
     numbers in the matrix by 10^x, where X is the exponent that would
     be used to display M in scientific notation.  For example, for M =
     5.123×10^{20}, the scale factor is 10^{20}.  PSPP displays the
     scaled values in format ‘F13.10’ and notes the scale factor in the
     output.

  3. Otherwise, PSPP displays the matrix values, without scaling, in
     format ‘F13.10’.

   The optional ‘TITLE’ subcommand specifies a title for the output text
or table, as a quoted string.  When it is omitted, the syntax of the
matrix expression is used as the title.

   Use the ‘SPACE’ subcommand to request extra space above the matrix
output.  With a numerical argument, it adds the specified number of
lines of blank space above the matrix.  With ‘NEWPAGE’ as an argument,
it prints the matrix at the top of a new page.  The ‘SPACE’ subcommand
has no effect when a matrix is output as a pivot table.

   The ‘RLABELS’ and ‘RNAMES’ subcommands, which are mutually exclusive,
can supply a label to accompany each row in the output.  With ‘RLABELS’,
specify the labels as comma-separated strings or other tokens.  With
‘RNAMES’, specify a single expression that evaluates to a vector of
strings.  Either way, if there are more labels than rows, the extra
labels are ignored, and if there are more rows than labels, the extra
rows are unlabeled.  For output to a pivot table with ‘RLABELS’, the
labels can be any length; otherwise, the labels are truncated to 8
bytes.

   The ‘CLABELS’ and ‘CNAMES’ subcommands work for labeling columns as
‘RLABELS’ and ‘RNAMES’ do for labeling rows.

   When the EXPRESSION is omitted, ‘PRINT’ does not output a matrix.
Instead, it outputs only the text specified on ‘TITLE’, if any, preceded
by any space specified on the ‘SPACE’ subcommand, if any.  Any other
subcommands are ignored, and the command acts as if ‘MDISPLAY’ is set to
‘TEXT’ regardless of its actual setting.

   The following syntax demonstrates two different ways to label the
rows and columns of a matrix with ‘PRINT’:

     MATRIX.
     COMPUTE m={1, 2, 3; 4, 5, 6; 7, 8, 9}.
     PRINT m/RLABELS=a, b, c/CLABELS=x, y, z.

     COMPUTE rlabels={"a", "b", "c"}.
     COMPUTE clabels={"x", "y", "z"}.
     PRINT m/RNAMES=rlabels/CNAMES=clabels.
     END MATRIX.

With ‘MDISPLAY=TEXT’ (the default), this program outputs the following
(twice):

     m
                     x        y        z
     a               1        2        3
     b               4        5        6
     c               7        8        9

With ‘SET MDISPLAY=TABLES.’ added above ‘MATRIX.’, the output becomes
the following (twice):

 [image src="pspp-figures/matrix-print.png" text="    m
+-+-+-+-+
| |x|y|z|
+-+-+-+-+
|a|1|2|3|
|b|4|5|6|
|c|7|8|9|
+-+-+-+-+" ]



File: pspp.info,  Node: Matrix DO IF Command,  Next: Matrix LOOP and BREAK Commands,  Prev: Matrix PRINT Command,  Up: MATRIX

16.4.6 The ‘DO IF’ Command
--------------------------

     DO IF expression.
       ...matrix commands...
     [ELSE IF expression.
       ...matrix commands...]...
     [ELSE
       ...matrix commands...]
     END IF.

   A ‘DO IF’ command evaluates its expression argument.  If the ‘DO IF’
expression evaluates to true, then PSPP executes the associated
commands.  Otherwise, PSPP evaluates the expression on each ‘ELSE IF’
clause (if any) in order, and executes the commands associated with the
first one that yields a true value.  Finally, if the ‘DO IF’ and all the
‘ELSE IF’ expressions all evaluate to false, PSPP executes the commands
following the ‘ELSE’ clause (if any).

   Each expression on ‘DO IF’ and ‘ELSE IF’ must evaluate to a scalar.
Positive scalars are considered to be true, and scalars that are zero or
negative are considered to be false.

   The following matrix language fragment sets ‘b’ to the term following
‘a’ in the Juggler sequence
(https://en.wikipedia.org/wiki/Juggler_sequence):

     DO IF MOD(a, 2) = 0.
       COMPUTE b = TRUNC(a &** (1/2)).
     ELSE.
       COMPUTE b = TRUNC(a &** (3/2)).
     END IF.


File: pspp.info,  Node: Matrix LOOP and BREAK Commands,  Next: Matrix READ and WRITE Commands,  Prev: Matrix DO IF Command,  Up: MATRIX

16.4.7 The ‘LOOP’ and ‘BREAK’ Commands
--------------------------------------

     LOOP [var=first TO last [BY step]] [IF expression].
       ...matrix commands...
     END LOOP [IF expression].

     BREAK.

   The ‘LOOP’ command executes a nested group of matrix commands, called
the loop’s “body”, repeatedly.  It has three optional clauses that
control how many times the loop body executes.  Regardless of these
clauses, the global ‘MXLOOPS’ setting, which defaults to 40, also limits
the number of iterations of a loop.  To iterate more times, raise the
maximum with ‘SET MXLOOPS’ outside of the ‘MATRIX’ command (*note SET
MXLOOPS::).

   The optional index clause causes VAR to be assigned successive values
on each trip through the loop: first FIRST, then FIRST + STEP, then
FIRST + 2 × STEP, and so on.  The loop ends when VAR > LAST, for
positive STEP, or VAR < LAST, for negative STEP.  If STEP is not
specified, it defaults to 1.  All the index clause expressions must
evaluate to scalars, and non-integers are rounded toward zero.  If STEP
evaluates as zero (or rounds to zero), then the loop body never
executes.

   The optional ‘IF’ on ‘LOOP’ is evaluated before each iteration
through the loop body.  If its expression, which must evaluate to a
scalar, is zero or negative, then the loop terminates without executing
the loop body.

   The optional ‘IF’ on ‘END LOOP’ is evaluated after each iteration
through the loop body.  If its expression, which must evaluate to a
scalar, is zero or negative, then the loop terminates.

   The following computes and prints l(n), whose value is the number of
steps in the Juggler sequence
(https://en.wikipedia.org/wiki/Juggler_sequence) for n, for n from 2 to
10 inclusive:

     COMPUTE l = {}.
     LOOP n = 2 TO 10.
       COMPUTE a = n.
       LOOP i = 1 TO 100.
         DO IF MOD(a, 2) = 0.
           COMPUTE a = TRUNC(a &** (1/2)).
         ELSE.
           COMPUTE a = TRUNC(a &** (3/2)).
         END IF.
       END LOOP IF a = 1.
       COMPUTE l = {l; i}.
     END LOOP.
     PRINT l.

* Menu:

* Matrix BREAK Command::


File: pspp.info,  Node: Matrix BREAK Command,  Up: Matrix LOOP and BREAK Commands

16.4.7.1 The ‘BREAK’ Command
............................

The ‘BREAK’ command may be used inside a loop body, ordinarily within a
‘DO IF’ command.  If it is executed, then the loop terminates
immediately, jumping to the command just following ‘END LOOP’.  When
multiple ‘LOOP’ commands nest, ‘BREAK’ terminates the innermost loop.

   The following example is a revision of the one above that shows how
‘BREAK’ could substitute for the index and ‘IF’ clauses on ‘LOOP’ and
‘END LOOP’:

     COMPUTE l = {}.
     LOOP n = 2 TO 10.
       COMPUTE a = n.
       COMPUTE i = 1.
       LOOP.
         DO IF MOD(a, 2) = 0.
           COMPUTE a = TRUNC(a &** (1/2)).
         ELSE.
           COMPUTE a = TRUNC(a &** (3/2)).
         END IF.
         DO IF a = 1.
           BREAK.
         END IF.
         COMPUTE i = i + 1.
       END LOOP.
       COMPUTE l = {l; i}.
     END LOOP.
     PRINT l.


File: pspp.info,  Node: Matrix READ and WRITE Commands,  Next: Matrix GET Command,  Prev: Matrix LOOP and BREAK Commands,  Up: MATRIX

16.4.8 The ‘READ’ and ‘WRITE’ Commands
--------------------------------------

The ‘READ’ and ‘WRITE’ commands perform matrix input and output with
text files.  They share the following syntax for specifying how data is
divided among input lines:

     /FIELD=first TO last [BY width]
     [/FORMAT=format]

   Both commands require the ‘FIELD’ subcommand.  It specifies the range
of columns, from FIRST to LAST, inclusive, that the data occupies on
each line of the file.  The leftmost column is column 1.  The columns
must be literal numbers, not expressions.  To use entire lines, even if
they might be very long, specify a column range such as ‘1 TO 100000’.

   The ‘FORMAT’ subcommand is optional for numerical matrices.  For
string matrix input and output, specify an ‘A’ format.  In addition to
‘FORMAT’, the optional ‘BY’ specification on ‘FIELD’ determine the
meaning of each text line:

   • With neither ‘BY’ nor ‘FORMAT’, the numbers in the text file are in
     ‘F’ format separated by spaces or commas.  For ‘WRITE’, PSPP uses
     as many digits of precision as needed to accurately represent the
     numbers in the matrix.

   • ‘BY width’ divides the input area into fixed-width fields with the
     given width.  The input area must be a multiple of width columns
     wide.  Numbers are read or written as ‘Fwidth.0’ format.

   • ‘FORMAT="countF"’ divides the input area into integer count
     equal-width fields per line.  The input area must be a multiple of
     count columns wide.  Another format type may be substituted for
     ‘F’.

   • ‘FORMAT=Fw’[‘.d’] divides the input area into fixed-width fields
     with width w.  The input area must be a multiple of w columns wide.
     Another format type may be substituted for ‘F’.  The ‘READ’ command
     disregards d.

   • ‘FORMAT=F’ specifies format ‘F’ without indicating a field width.
     Another format type may be substituted for ‘F’.  The ‘WRITE’
     command accepts this form, but it has no effect unless ‘BY’ is also
     used to specify a field width.

   If ‘BY’ and ‘FORMAT’ both specify or imply a field width, then they
must indicate the same field width.

* Menu:

* Matrix READ Command::
* Matrix WRITE Command::


File: pspp.info,  Node: Matrix READ Command,  Next: Matrix WRITE Command,  Up: Matrix READ and WRITE Commands

16.4.8.1 The ‘READ’ Command
...........................

     READ variable[(index[,index])]
          [/FILE=file]
          /FIELD=first TO last [BY width]
          [/FORMAT=format]
          [/SIZE=expression]
          [/MODE={RECTANGULAR | SYMMETRIC}]
          [/REREAD].

   The ‘READ’ command reads from a text file into a matrix variable.
Specify the target variable just after the command name, either just a
variable name to create or replace an entire variable, or a variable
name followed by an indexing expression to replace a submatrix of an
existing variable.

   The ‘FILE’ subcommand is required in the first ‘READ’ command that
appears within ‘MATRIX’.  It specifies the text file to be read, either
as a file name in quotes or a file handle previously declared on ‘FILE
HANDLE’ (*note FILE HANDLE::).  Later ‘READ’ commands (in syntax order)
use the previous referenced file if ‘FILE’ is omitted.

   The ‘FIELD’ and ‘FORMAT’ subcommands specify how input lines are
interpreted.  ‘FIELD’ is required, but ‘FORMAT’ is optional.  *Note
Matrix READ and WRITE Commands::, for details.

   The ‘SIZE’ subcommand is required for reading into an entire
variable.  Its restricted expression argument should evaluate to a
2-element vector ‘{N, M}’ or ‘{N; M}’, which indicates a N×M matrix
destination.  A scalar N is also allowed and indicates a N×1 column
vector destination.  When the destination is a submatrix, ‘SIZE’ is
optional, and if it is present then it must match the size of the
submatrix.

   By default, or with ‘MODE=RECTANGULAR’, the command reads an entry
for every row and column.  With ‘MODE=SYMMETRIC’, the command reads only
the entries on and below the matrix’s main diagonal, and copies the
entries above the main diagonal from the corresponding symmetric entries
below it.  Only square matrices may use ‘MODE=SYMMETRIC’.

   Ordinarily, each ‘READ’ command starts from a new line in the text
file.  Specify the ‘REREAD’ subcommand to instead start from the last
line read by the previous ‘READ’ command.  This has no effect for the
first ‘READ’ command to read from a particular file.  It is also
ineffective just after a command that uses the ‘EOF’ matrix function
(*note EOF Matrix Function::) on a particular file, because ‘EOF’ has to
try to read the next line from the file to determine whether the file
contains more input.

Example 1: Basic Use
....................

The following matrix program reads the same matrix ‘{1, 2, 4; 2, 3, 5;
4, 5, 6}’ into matrix variables ‘v’, ‘w’, and ‘x’:

     READ v /FILE='input.txt' /FIELD=1 TO 100 /SIZE={3, 3}.
     READ w /FIELD=1 TO 100 /SIZE={3; 3} /MODE=SYMMETRIC.
     READ x /FIELD=1 TO 100 BY 1/SIZE={3, 3} /MODE=SYMMETRIC.

given that ‘input.txt’ contains the following:

     1, 2, 4
     2, 3, 5
     4, 5, 6
     1
     2 3
     4 5 6
     1
     23
     456

   The ‘READ’ command will read as many lines of input as needed for a
particular row, so it’s also acceptable to break any of the lines above
into multiple lines.  For example, the first line ‘1, 2, 4’ could be
written with a line break following either or both commas.

Example 2: Reading into a Submatrix
...................................

The following reads a 5×5 matrix from ‘input2.txt’, reversing the order
of the rows:

     COMPUTE m = MAKE(5, 5, 0).
     LOOP r = 5 TO 1 BY -1.
       READ m(r, :) /FILE='input2.txt' /FIELD=1 TO 100.
     END LOOP.

Example 3: Using ‘REREAD’
.........................

Suppose each of the 5 lines in a file ‘input3.txt’ starts with an
integer COUNT followed by COUNT numbers, e.g.:

     1 5
     3 1 2 3
     5 6 -1 2 5 1
     2 8 9
     3 1 3 2

Then, the following reads this file into a matrix ‘m’:

     COMPUTE m = MAKE(5, 5, 0).
     LOOP i = 1 TO 5.
       READ count /FILE='input3.txt' /FIELD=1 TO 1 /SIZE=1.
       READ m(i, 1:count) /FIELD=3 TO 100 /REREAD.
     END LOOP.


File: pspp.info,  Node: Matrix WRITE Command,  Prev: Matrix READ Command,  Up: Matrix READ and WRITE Commands

16.4.8.2 The ‘WRITE’ Command
............................

     WRITE expression
           [/OUTFILE=file]
           /FIELD=first TO last [BY width]
           [/FORMAT=format]
           [/MODE={RECTANGULAR | TRIANGULAR}]
           [/HOLD].

   The ‘WRITE’ command evaluates expression and writes its value to a
text file in a specified format.  Write the expression to evaluate just
after the command name.

   The ‘OUTFILE’ subcommand is required in the first ‘WRITE’ command
that appears within ‘MATRIX’.  It specifies the text file to be written,
either as a file name in quotes or a file handle previously declared on
‘FILE HANDLE’ (*note FILE HANDLE::).  Later ‘WRITE’ commands (in syntax
order) use the previous referenced file if ‘FILE’ is omitted.

   The ‘FIELD’ and ‘FORMAT’ subcommands specify how output lines are
formed.  ‘FIELD’ is required, but ‘FORMAT’ is optional.  *Note Matrix
READ and WRITE Commands::, for details.

   By default, or with ‘MODE=RECTANGULAR’, the command writes an entry
for every row and column.  With ‘MODE=TRIANGULAR’, the command writes
only the entries on and below the matrix’s main diagonal.  Entries above
the diagonal are not written.  Only square matrices may be written with
‘MODE=TRIANGULAR’.

   Ordinarily, each ‘WRITE’ command writes complete lines to the output
file.  With ‘HOLD’, the final line written by ‘WRITE’ will be held back
for the next ‘WRITE’ command to augment.  This can be useful to write
more than one matrix on a single output line.

Example 1: Basic Usage
......................

This matrix program:

     WRITE {1, 2; 3, 4} /OUTFILE='matrix.txt' /FIELD=1 TO 80.

writes the following to ‘matrix.txt’:

      1 2
      3 4

Example 2: Triangular Matrix
............................

This matrix program:

     WRITE MAGIC(5) /OUTFILE='matrix.txt' /FIELD=1 TO 80 BY 5 /MODE=TRIANGULAR.

writes the following to ‘matrix.txt’:

         17
         23    5
          4    6   13
         10   12   19   21
         11   18   25    2    9


File: pspp.info,  Node: Matrix GET Command,  Next: Matrix SAVE Command,  Prev: Matrix READ and WRITE Commands,  Up: MATRIX

16.4.9 The ‘GET’ Command
------------------------

     GET variable[(index[,index])]
         [/FILE={file | *}]
         [/VARIABLES=variable...]
         [/NAMES=variable]
         [/MISSING={ACCEPT | OMIT | number}]
         [/SYSMIS={OMIT | number}].

   The ‘READ’ command reads numeric data from an SPSS system file,
SPSS/PC+ system file, or SPSS portable file into a matrix variable or
submatrix:

   • To read data into a variable, specify just its name following
     ‘GET’.  The variable need not already exist; if it does, it is
     replaced.  The variable will have as many columns as there are
     variables specified on the ‘VARIABLES’ subcommand and as many rows
     as there are cases in the input file.

   • To read data into a submatrix, specify the name of an existing
     variable, followed by an indexing expression, just after ‘GET’.
     The submatrix must have as many columns as variables specified on
     ‘VARIABLES’ and as many rows as cases in the input file.

   Specify the name or handle of the file to be read on ‘FILE’.  Use
‘*’, or simply omit the ‘FILE’ subcommand, to read from the active file.
Reading from the active file is only permitted if it was already defined
outside ‘MATRIX’.

   List the variables to be read as columns in the matrix on the
‘VARIABLES’ subcommand.  The list can use ‘TO’ for collections of
variables or ‘ALL’ for all variables.  If ‘VARIABLES’ is omitted, all
variables are read.  Only numeric variables may be read.

   If a variable is named on ‘NAMES’, then the names of the variables
read as data columns are stored in a string vector within the given
name, replacing any existing matrix variable with that name.  Variable
names are truncated to 8 bytes.

   The ‘MISSING’ and ‘SYSMIS’ subcommands control the treatment of
missing values in the input file.  By default, any user- or
system-missing data in the variables being read from the input causes an
error that prevents ‘GET’ from executing.  To accept missing values,
specify one of the following settings on ‘MISSING’:

‘ACCEPT’
     Accept user-missing values with no change.

     By default, system-missing values still yield an error.  Use the
     ‘SYSMIS’ subcommand to change this treatment:

     ‘OMIT’
          Skip any case that contains a system-missing value.

     number
          Recode the system-missing value to number.

‘OMIT’
     Skip any case that contains any user- or system-missing value.

number
     Recode all user- and system-missing values to number.

   The ‘SYSMIS’ subcommand has an effect only with ‘MISSING=ACCEPT’.


File: pspp.info,  Node: Matrix SAVE Command,  Next: Matrix MGET Command,  Prev: Matrix GET Command,  Up: MATRIX

16.4.10 The ‘SAVE’ Command
--------------------------

     SAVE expression
          [/OUTFILE={file | *}]
          [/VARIABLES=variable...]
          [/NAMES=expression]
          [/STRINGS=variable...].

   The ‘SAVE’ matrix command evaluates expression and writes the
resulting matrix to an SPSS system file.  In the system file, each
matrix row becomes a case and each column becomes a variable.

   Specify the name or handle of the SPSS system file on the ‘OUTFILE’
subcommand, or ‘*’ to write the output as the new active file.  The
‘OUTFILE’ subcommand is required on the first ‘SAVE’ command, in syntax
order, within ‘MATRIX’.  For ‘SAVE’ commands after the first, the
default output file is the same as the previous.

   When multiple ‘SAVE’ commands write to one destination within a
single ‘MATRIX’, the later commands append to the same output file.  All
the matrices written to the file must have the same number of columns.
The ‘VARIABLES’, ‘NAMES’, and ‘STRINGS’ subcommands are honored only for
the first ‘SAVE’ command that writes to a given file.

   By default, ‘SAVE’ names the variables in the output file ‘COL1’
through ‘COLn’.  Use ‘VARIABLES’ or ‘NAMES’ to give the variables
meaningful names.  The ‘VARIABLES’ subcommand accepts a comma-separated
list of variable names.  Its alternative, ‘NAMES’, instead accepts an
expression that must evaluate to a row or column string vector of names.
The number of names need not exactly match the number of columns in the
matrix to be written: extra names are ignored; extra columns use default
names.

   By default, ‘SAVE’ assumes that the matrix to be written is all
numeric.  To write string columns, specify a comma-separated list of the
string columns’ variable names on ‘STRINGS’.


File: pspp.info,  Node: Matrix MGET Command,  Next: Matrix MSAVE Command,  Prev: Matrix SAVE Command,  Up: MATRIX

16.4.11 The ‘MGET’ Command
--------------------------

     MGET [/FILE=file]
          [/TYPE={COV | CORR | MEAN | STDDEV | N | COUNT}].

   The ‘MGET’ command reads the data from a matrix file (*note Matrix
Files::) into matrix variables.

   All of ‘MGET’’s subcommands are optional.  Specify the name or handle
of the matrix file to be read on the ‘FILE’ subcommand; if it is
omitted, then the command reads the active file.

   By default, ‘MGET’ reads all of the data from the matrix file.
Specify a space-delimited list of matrix types on ‘TYPE’ to limit the
kinds of data to the one specified:

‘COV’
     Covariance matrix.

‘CORR’
     Correlation coefficient matrix.

‘MEAN’
     Vector of means.

‘STDDEV’
     Vector of standard deviations.

‘N’
     Vector of case counts.

‘COUNT’
     Vector of counts.

   ‘MGET’ reads the entire matrix file and automatically names, creates,
and populates matrix variables using its contents.  It constructs the
name of each variable by concatenating the following:

   • A 2-character prefix that identifies the type of the matrix:

     ‘CV’
          Covariance matrix.

     ‘CR’
          Correlation coefficient matrix.

     ‘MN’
          Vector of means.

     ‘SD’
          Vector of standard deviations.

     ‘NC’
          Vector of case counts.

     ‘CN’
          Vector of counts.

   • If the matrix file has factor variables, ‘Fn’, where n is a number
     identifying a group of factors: ‘F1’ for the first group, ‘F2’ for
     the second, and so on.  This part is omitted for pooled data (where
     the factors all have the system-missing value).

   • If the matrix file has split file variables, ‘Sn’, where n is a
     number identifying a split group: ‘S1’ for the first group, ‘S2’
     for the second, and so on.

   If ‘MGET’ chooses the name of an existing variable, it issues a
warning and does not change the variable.


File: pspp.info,  Node: Matrix MSAVE Command,  Next: Matrix DISPLAY Command,  Prev: Matrix MGET Command,  Up: MATRIX

16.4.12 The ‘MSAVE’ Command
---------------------------

     MSAVE expression
           /TYPE={COV | CORR | MEAN | STDDEV | N | COUNT}
           [/FACTOR=expression]
           [/SPLIT=expression]
           [/OUTFILE=file]
           [/VARIABLES=variable...]
           [/SNAMES=variable...]
           [/FNAMES=variable...].

   The ‘MSAVE’ command evaluates the expression specified just after the
command name, and writes the resulting matrix to a matrix file (*note
Matrix Files::).

   The ‘TYPE’ subcommand is required.  It specifies the ‘ROWTYPE_’ to
write along with this matrix.

   The ‘FACTOR’ and ‘SPLIT’ subcommands are required on the first
‘MSAVE’ if and only if the matrix file has factor or split variables,
respectively.  After that, their values are carried along from one
‘MSAVE’ command to the next in syntax order as defaults.  Each one takes
an expression that must evaluate to a vector with the same number of
entries as the matrix has factor or split variables, respectively.  Each
‘MSAVE’ only writes data for a single combination of factor and split
variables, so many ‘MSAVE’ commands (or one inside a loop) may be needed
to write a complete set.

   The remaining ‘MSAVE’ subcommands define the format of the matrix
file.  All of the ‘MSAVE’ commands within a given matrix program write
to the same matrix file, so these subcommands are only meaningful on the
first ‘MSAVE’ command within a matrix program.  (If they are given again
on later ‘MSAVE’ commands, then they must have the same values as on the
first.)

   The ‘OUTFILE’ subcommand specifies the name or handle of the matrix
file to be written.  Output must go to an external file, not a data set
or the active file.

   The ‘VARIABLES’ subcommand specifies a comma-separated list of the
names of the continuous variables to be written to the matrix file.  The
‘TO’ keyword can be used to define variables named with consecutive
integer suffixes.  These names become column names and names that appear
in ‘VARNAME_’ in the matrix file.  ‘ROWTYPE_’ and ‘VARNAME_’ are not
allowed on ‘VARIABLES’.  If ‘VARIABLES’ is omitted, then PSPP uses the
names ‘COL1’, ‘COL2’, and so on.

   The ‘FNAMES’ subcommand may be used to supply a comma-separated list
of factor variable names.  The default names are ‘FAC1’, ‘FAC2’, and so
on.

   The ‘SNAMES’ subcommand can supply a comma-separated list of split
variable names.  The default names are ‘SPL1’, ‘SPL2’, and so on.


File: pspp.info,  Node: Matrix DISPLAY Command,  Next: Matrix RELEASE Command,  Prev: Matrix MSAVE Command,  Up: MATRIX

16.4.13 The ‘DISPLAY’ Command
-----------------------------

     DISPLAY [{DICTIONARY | STATUS}].

   The ‘DISPLAY’ command makes PSPP display a table with the name and
dimensions of each matrix variable.  The ‘DICTIONARY’ and ‘STATUS’
keywords are accepted but have no effect.


File: pspp.info,  Node: Matrix RELEASE Command,  Prev: Matrix DISPLAY Command,  Up: MATRIX

16.4.14 The ‘RELEASE’ Command
-----------------------------

     RELEASE variable....

   The ‘RELEASE’ command accepts a comma-separated list of matrix
variable names.  It deletes each variable and releases the memory
associated with it.

   The ‘END MATRIX’ command releases all matrix variables.


File: pspp.info,  Node: Utilities,  Next: Invoking pspp-convert,  Prev: Matrices,  Up: Top

17 Utilities
************

Commands that don’t fit any other category are placed here.

   Most of these commands are not affected by commands like ‘IF’ and
‘LOOP’: they take effect only once, unconditionally, at the time that
they are encountered in the input.

* Menu:

* ADD DOCUMENT::                Add documentary text to the active dataset.
* CACHE::                       Ignored for compatibility.
* CD::                          Change the current directory.
* COMMENT::                     Document your syntax file.
* DOCUMENT::                    Document the active dataset.
* DISPLAY DOCUMENTS::           Display active dataset documents.
* DISPLAY FILE LABEL::          Display the active dataset label.
* DROP DOCUMENTS::              Remove documents from the active dataset.
* ECHO::                        Write a string to the output stream.
* ERASE::                       Erase a file.
* EXECUTE::                     Execute pending transformations.
* FILE LABEL::                  Set the active dataset’s label.
* FINISH::                      Terminate the PSPP session.
* HOST::                        Temporarily return to the operating system.
* INCLUDE::                     Include a file within the current one.
* INSERT::                      Insert a file within the current one.
* OUTPUT::                      Modify the appearance of the output.
* PERMISSIONS::                 Change permissions on a file.
* PRESERVE and RESTORE::        Saving settings and restoring them later.
* SET::                         Adjust PSPP runtime parameters.
* SHOW::                        Display runtime parameters.
* SUBTITLE::                    Provide a document subtitle.
* TITLE::                       Provide a document title.


File: pspp.info,  Node: ADD DOCUMENT,  Next: CACHE,  Up: Utilities

17.1 ADD DOCUMENT
=================

     ADD DOCUMENT
         ’line one’ ’line two’ ... ’last line’ .

   ‘ADD DOCUMENT’ adds one or more lines of descriptive commentary to
the active dataset.  Documents added in this way are saved to system
files.  They can be viewed using ‘SYSFILE INFO’ or ‘DISPLAY DOCUMENTS’.
They can be removed from the active dataset with ‘DROP DOCUMENTS’.

   Each line of documentary text must be enclosed in quotation marks,
and may not be more than 80 bytes long.  *Note DOCUMENT::.


File: pspp.info,  Node: CACHE,  Next: CD,  Prev: ADD DOCUMENT,  Up: Utilities

17.2 CACHE
==========

     CACHE.

   This command is accepted, for compatibility, but it has no effect.


File: pspp.info,  Node: CD,  Next: COMMENT,  Prev: CACHE,  Up: Utilities

17.3 CD
=======

     CD ’new directory’ .

   ‘CD’ changes the current directory.  The new directory becomes that
specified by the command.


File: pspp.info,  Node: COMMENT,  Next: DOCUMENT,  Prev: CD,  Up: Utilities

17.4 COMMENT
============

     Comment commands:
         COMMENT comment text ... .
         *comment text ... .

     Comments within a line of syntax:
         FREQUENCIES /VARIABLES=v0 v1 v2.  /* All our categorical variables.

   ‘COMMENT’ is ignored.  It is used to provide information to the
author and other readers of the PSPP syntax file.

   ‘COMMENT’ can extend over any number of lines.  It ends at a dot at
the end of a line or a blank line.  The comment may contain any
characters.

   PSPP also supports comments within a line of syntax, introduced with
‘/*’.  These comments end at the first ‘*/’ or at the end of the line,
whichever comes first.  A line that contains just this kind of comment
is considered blank and ends the current command.


File: pspp.info,  Node: DOCUMENT,  Next: DISPLAY DOCUMENTS,  Prev: COMMENT,  Up: Utilities

17.5 DOCUMENT
=============

     DOCUMENT DOCUMENTARY_TEXT.

   ‘DOCUMENT’ adds one or more lines of descriptive commentary to the
active dataset.  Documents added in this way are saved to system files.
They can be viewed using ‘SYSFILE INFO’ or ‘DISPLAY DOCUMENTS’.  They
can be removed from the active dataset with ‘DROP DOCUMENTS’.

   Specify the DOCUMENTARY TEXT following the ‘DOCUMENT’ keyword.  It is
interpreted literally—any quotes or other punctuation marks are included
in the file.  You can extend the documentary text over as many lines as
necessary, including blank lines to separate paragraphs.  Lines are
truncated at 80 bytes.  Don’t forget to terminate the command with a dot
at the end of a line.  *Note ADD DOCUMENT::.


File: pspp.info,  Node: DISPLAY DOCUMENTS,  Next: DISPLAY FILE LABEL,  Prev: DOCUMENT,  Up: Utilities

17.6 DISPLAY DOCUMENTS
======================

     DISPLAY DOCUMENTS.

   ‘DISPLAY DOCUMENTS’ displays the documents in the active dataset.
Each document is preceded by a line giving the time and date that it was
added.  *Note DOCUMENT::.


File: pspp.info,  Node: DISPLAY FILE LABEL,  Next: DROP DOCUMENTS,  Prev: DISPLAY DOCUMENTS,  Up: Utilities

17.7 DISPLAY FILE LABEL
=======================

     DISPLAY FILE LABEL.

   ‘DISPLAY FILE LABEL’ displays the file label contained in the active
dataset, if any.  *Note FILE LABEL::.

   This command is a PSPP extension.


File: pspp.info,  Node: DROP DOCUMENTS,  Next: ECHO,  Prev: DISPLAY FILE LABEL,  Up: Utilities

17.8 DROP DOCUMENTS
===================

     DROP DOCUMENTS.

   ‘DROP DOCUMENTS’ removes all documents from the active dataset.  New
documents can be added with ‘DOCUMENT’ (*note DOCUMENT::).

   ‘DROP DOCUMENTS’ changes only the active dataset.  It does not modify
any system files stored on disk.


File: pspp.info,  Node: ECHO,  Next: ERASE,  Prev: DROP DOCUMENTS,  Up: Utilities

17.9 ECHO
=========

     ECHO ’arbitrary text’ .

   Use ‘ECHO’ to write arbitrary text to the output stream.  The text
should be enclosed in quotation marks following the normal rules for
string tokens (*note Tokens::).


File: pspp.info,  Node: ERASE,  Next: EXECUTE,  Prev: ECHO,  Up: Utilities

17.10 ERASE
===========

     ERASE FILE FILE_NAME.

   ‘ERASE FILE’ deletes a file from the local file system.  FILE_NAME
must be quoted.  This command cannot be used if the SAFER (*note SET::)
setting is active.


File: pspp.info,  Node: EXECUTE,  Next: FILE LABEL,  Prev: ERASE,  Up: Utilities

17.11 EXECUTE
=============

     EXECUTE.

   ‘EXECUTE’ causes the active dataset to be read and all pending
transformations to be executed.


File: pspp.info,  Node: FILE LABEL,  Next: FINISH,  Prev: EXECUTE,  Up: Utilities

17.12 FILE LABEL
================

     FILE LABEL FILE_LABEL.

   ‘FILE LABEL’ provides a title for the active dataset.  This title is
saved into system files and portable files that are created during this
PSPP run.

   FILE_LABEL should not be quoted.  If quotes are included, they are
literally interpreted and become part of the file label.


File: pspp.info,  Node: FINISH,  Next: HOST,  Prev: FILE LABEL,  Up: Utilities

17.13 FINISH
============

     FINISH.

   ‘FINISH’ terminates the current PSPP session and returns control to
the operating system.


File: pspp.info,  Node: HOST,  Next: INCLUDE,  Prev: FINISH,  Up: Utilities

17.14 HOST
==========

In the syntax below, the square brackets must be included in the command
syntax and do not indicate that that their contents are optional.

     HOST COMMAND=[’COMMAND’...]
          TIMELIMIT=SECS.

   ‘HOST’ executes one or more commands, each provided as a string in
the required ‘COMMAND’ subcommand, in the shell of the underlying
operating system.  PSPP runs each command in a separate shell process
and waits for it to finish before running the next one.  If a command
fails (with a nonzero exit status, or because it is killed by a signal),
then PSPP does not run any remaining commands.

   PSPP provides ‘/dev/null’ as the shell’s standard input.  If a
process needs to read from stdin, redirect from a file or device, or use
a pipe.

   PSPP displays the shell’s standard output and standard error as PSPP
output.  Redirect to a file or ‘/dev/null’ or another device if this is
not desired.

   The following example runs ‘rsync’ to copy a file from a remote
server to the local file ‘data.txt’, writing ‘rsync’’s own output to
‘rsync-log.txt’.  PSPP displays the command’s error output, if any.  If
‘rsync’ needs to prompt the user (e.g. to obtain a password), the
command fails.  Only if the ‘rsync’ succeeds, PSPP then runs the
‘sha512sum’ command.

     HOST COMMAND=['rsync remote:data.txt data.txt > rsync-log.txt'
                   'sha512sum -c data.txt.sha512sum].

   By default, PSPP waits as long as necessary for the series of
commands to complete.  Use the optional ‘TIMELIMIT’ subcommand to limit
the execution time to the specified number of seconds.

   PSPP built for mingw does not support all the features of ‘HOST’.

   PSPP rejects this command if the SAFER (*note SET::) setting is
active.


File: pspp.info,  Node: INCLUDE,  Next: INSERT,  Prev: HOST,  Up: Utilities

17.15 INCLUDE
=============

             INCLUDE [FILE=]’FILE_NAME’ [ENCODING=’ENCODING’].

   ‘INCLUDE’ causes the PSPP command processor to read an additional
command file as if it were included bodily in the current command file.
If errors are encountered in the included file, then command processing
stops and no more commands are processed.  Include files may be nested
to any depth, up to the limit of available memory.

   The ‘INSERT’ command (*note INSERT::) is a more flexible alternative
to ‘INCLUDE’.  An ‘INCLUDE’ command acts the same as ‘INSERT’ with
‘ERROR=STOP CD=NO SYNTAX=BATCH’ specified.

   The optional ‘ENCODING’ subcommand has the same meaning as with
‘INSERT’.


File: pspp.info,  Node: INSERT,  Next: OUTPUT,  Prev: INCLUDE,  Up: Utilities

17.16 INSERT
============

          INSERT [FILE=]’FILE_NAME’
             [CD={NO,YES}]
             [ERROR={CONTINUE,STOP}]
             [SYNTAX={BATCH,INTERACTIVE}]
             [ENCODING={LOCALE, ’CHARSET_NAME’}].

   ‘INSERT’ is similar to ‘INCLUDE’ (*note INCLUDE::) but somewhat more
flexible.  It causes the command processor to read a file as if it were
embedded in the current command file.

   If ‘CD=YES’ is specified, then before including the file, the current
directory becomes the directory of the included file.  The default
setting is ‘CD=NO’.  Note that this directory remains current until it
is changed explicitly (with the ‘CD’ command, or a subsequent ‘INSERT’
command with the ‘CD=YES’ option).  It does not revert to its original
setting even after the included file is finished processing.

   If ‘ERROR=STOP’ is specified, errors encountered in the inserted file
causes processing to immediately cease.  Otherwise processing continues
at the next command.  The default setting is ‘ERROR=CONTINUE’.

   If ‘SYNTAX=INTERACTIVE’ is specified then the syntax contained in the
included file must conform to interactive syntax conventions.  *Note
Syntax Variants::.  The default setting is ‘SYNTAX=BATCH’.

   ‘ENCODING’ optionally specifies the character set used by the
included file.  Its argument, which is not case-sensitive, must be in
one of the following forms:

‘LOCALE’
     The encoding used by the system locale, or as overridden by the
     ‘SET’ command (*note SET::).  On GNU/Linux and other Unix-like
     systems, environment variables, e.g. ‘LANG’ or ‘LC_ALL’, determine
     the system locale.

CHARSET_NAME
     One of the character set names listed by IANA at
     <http://www.iana.org/assignments/character-sets>.  Some examples
     are ‘ASCII’ (United States), ‘ISO-8859-1’ (western Europe),
     ‘EUC-JP’ (Japan), and ‘windows-1252’ (Windows).  Not all systems
     support all character sets.

‘Auto,ENCODING’
     Automatically detects whether a syntax file is encoded in an
     Unicode encoding such as UTF-8, UTF-16, or UTF-32.  If it is not,
     then PSPP generally assumes that the file is encoded in ENCODING
     (an IANA character set name).  However, if ENCODING is UTF-8, and
     the syntax file is not valid UTF-8, PSPP instead assumes that the
     file is encoded in ‘windows-1252’.

     For best results, ENCODING should be an ASCII-compatible encoding
     (the most common locale encodings are all ASCII-compatible),
     because encodings that are not ASCII compatible cannot be
     automatically distinguished from UTF-8.

‘Auto’
‘Auto,Locale’
     Automatic detection, as above, with the default encoding taken from
     the system locale or the setting on ‘SET LOCALE’.

   When ENCODING is not specified, the default is taken from the
‘--syntax-encoding’ command option, if it was specified, and otherwise
it is ‘Auto’.


File: pspp.info,  Node: OUTPUT,  Next: PERMISSIONS,  Prev: INSERT,  Up: Utilities

17.17 OUTPUT
============

     OUTPUT MODIFY
            /SELECT TABLES
            /TABLECELLS SELECT = [ CLASS... ]
                        FORMAT = FMT_SPEC.
     *Please note:* In the above synopsis the characters ‘[’ and ‘]’ are
     literals.  They must appear in the syntax to be interpreted.

   ‘OUTPUT’ changes the appearance of the tables in which results are
printed.  In particular, it can be used to set the format and precision
to which results are displayed.

   After running this command, the default table appearance parameters
will have been modified and each new output table generated uses the new
parameters.

   Following ‘/TABLECELLS SELECT =’ a list of cell classes must appear,
enclosed in square brackets.  This list determines the classes of values
should be selected for modification.  Each class can be:

RESIDUAL
     Residual values.  Default: F40.2.

CORRELATION
     Correlations.  Default: F40.3.

PERCENT
     Percentages.  Default: PCT40.1.

SIGNIFICANCE
     Significance of tests (p-values).  Default: F40.3.

COUNT
     Counts or sums of weights.  For a weighted data set, the default is
     the weight variable’s print format.  For an unweighted data set,
     the default is F40.0.

   For most other numeric values that appear in tables, ‘SET FORMAT’ may
be used to specify the format (*note SET FORMAT::).

   The value of FMT_SPEC must be a valid output format (*note Input and
Output Formats::).  Note that not all possible formats are meaningful
for all classes.


File: pspp.info,  Node: PERMISSIONS,  Next: PRESERVE and RESTORE,  Prev: OUTPUT,  Up: Utilities

17.18 PERMISSIONS
=================

     PERMISSIONS
             FILE=’FILE_NAME’
             /PERMISSIONS = {READONLY,WRITEABLE}.

   ‘PERMISSIONS’ changes the permissions of a file.  There is one
mandatory subcommand which specifies the permissions to which the file
should be changed.  If you set a file’s permission to ‘READONLY’, then
the file will become unwritable either by you or anyone else on the
system.  If you set the permission to ‘WRITEABLE’, then the file becomes
writeable by you; the permissions afforded to others are unchanged.
This command cannot be used if the ‘SAFER’ (*note SET::) setting is
active.


File: pspp.info,  Node: PRESERVE and RESTORE,  Next: SET,  Prev: PERMISSIONS,  Up: Utilities

17.19 PRESERVE and RESTORE
==========================

     PRESERVE.
     ...
     RESTORE.

   ‘PRESERVE’ saves all of the settings that ‘SET’ (*note SET::) can
adjust.  A later ‘RESTORE’ command restores those settings.

   ‘PRESERVE’ can be nested up to five levels deep.


File: pspp.info,  Node: SET,  Next: SHOW,  Prev: PRESERVE and RESTORE,  Up: Utilities

17.20 SET
=========

     SET

     (data input)
             /BLANKS={SYSMIS,’.’,number}
             /DECIMAL={DOT,COMMA}
             /FORMAT=FMT_SPEC
             /EPOCH={AUTOMATIC,YEAR}
             /RIB={NATIVE,MSBFIRST,LSBFIRST,VAX}
             /RRB={NATIVE,ISL,ISB,IDL,IDB,VF,VD,VG,ZS,ZL}

     (interaction)
             /MXERRS=MAX_ERRS
             /MXWARNS=MAX_WARNINGS
             /WORKSPACE=WORKSPACE_SIZE

     (syntax execution)
             /LOCALE=’LOCALE’
             /MXLOOPS=MAX_LOOPS
             /SEED={RANDOM,SEED_VALUE}
             /UNDEFINED={WARN,NOWARN}
             /FUZZBITS=FUZZBITS
             /SCALEMIN=COUNT

     (data output)
             /CC{A,B,C,D,E}={’NPRE,PRE,SUF,NSUF’,’NPRE.PRE.SUF.NSUF’}
             /DECIMAL={DOT,COMMA}
             /FORMAT=FMT_SPEC
             /LEADZERO={ON,OFF}
             /MDISPLAY={TEXT,TABLES}
             /SMALL=NUMBER
             /SUMMARY={NONE,COMMENT}
             /WIB={NATIVE,MSBFIRST,LSBFIRST,VAX}
             /WRB={NATIVE,ISL,ISB,IDL,IDB,VF,VD,VG,ZS,ZL}

     (output routing)
             /ERRORS={ON,OFF,TERMINAL,LISTING,BOTH,NONE}
             /MESSAGES={ON,OFF,TERMINAL,LISTING,BOTH,NONE}
             /PRINTBACK={ON,OFF,TERMINAL,LISTING,BOTH,NONE}
             /RESULTS={ON,OFF,TERMINAL,LISTING,BOTH,NONE}

     (output driver options)
             /HEADERS={NO,YES,BLANK}
             /LENGTH={NONE,N_LINES}
             /WIDTH={NARROW,WIDTH,N_CHARACTERS}
             /TNUMBERS={VALUES,LABELS,BOTH}
             /TVARS={NAMES,LABELS,BOTH}
             /TLOOK={NONE,FILE}

     (logging)
             /JOURNAL={ON,OFF} [’FILE_NAME’]

     (system files)
             /SCOMPRESSION={ON,OFF}

     (miscellaneous)
             /SAFER=ON
             /LOCALE=’STRING’

     (macros)
             /MEXPAND={ON,OFF}
             /MPRINT={ON,OFF}
             /MITERATE=NUMBER
             /MNEST=NUMBER

     (settings not yet implemented, but accepted and ignored)
             /BASETEXTDIRECTION={AUTOMATIC,RIGHTTOLEFT,LEFTTORIGHT}
             /BLOCK=’C’
             /BOX={’XXX’,’XXXXXXXXXXX’}
             /CACHE={ON,OFF}
             /CELLSBREAK=NUMBER
             /COMPRESSION={ON,OFF}
             /CMPTRANS={ON,OFF}
             /HEADER={NO,YES,BLANK}

   ‘SET’ allows the user to adjust several parameters relating to PSPP’s
execution.  Since there are many subcommands to this command, its
subcommands are examined in groups.

   For subcommands that take boolean values, ‘ON’ and ‘YES’ are
synonymous, as are ‘OFF’ and ‘NO’, when used as subcommand values.

   The data input subcommands affect the way that data is read from data
files.  The data input subcommands are

BLANKS
     This is the value assigned to an item data item that is empty or
     contains only white space.  An argument of SYSMIS or ’.’ causes the
     system-missing value to be assigned to null items.  This is the
     default.  Any real value may be assigned.

DECIMAL
     This value may be set to ‘DOT’ or ‘COMMA’.  Setting it to ‘DOT’
     causes the decimal point character to be ‘.’ and the grouping
     character to be ‘,’.  Setting it to ‘COMMA’ causes the decimal
     point character to be ‘,’ and the grouping character to be ‘.’.  If
     the setting is ‘COMMA’, then ‘,’ is not treated as a field
     separator in the ‘DATA LIST’ command (*note DATA LIST::).  The
     default value is determined from the system locale.

FORMAT
     Allows the default numeric input/output format to be specified.
     The default is F8.2.  *Note Input and Output Formats::.

EPOCH
     Specifies the range of years used when a 2-digit year is read from
     a data file or used in a date construction expression (*note Date
     Construction::).  If a 4-digit year is specified for the epoch,
     then 2-digit years are interpreted starting from that year, known
     as the epoch.  If ‘AUTOMATIC’ (the default) is specified, then the
     epoch begins 69 years before the current date.

RIB

     PSPP extension to set the byte ordering (endianness) used for
     reading data in IB or PIB format (*note Binary and Hexadecimal
     Numeric Formats::).  In ‘MSBFIRST’ ordering, the most-significant
     byte appears at the left end of a IB or PIB field.  In ‘LSBFIRST’
     ordering, the least-significant byte appears at the left end.
     ‘VAX’ ordering is like ‘MSBFIRST’, except that each pair of bytes
     is in reverse order.  ‘NATIVE’, the default, is equivalent to
     ‘MSBFIRST’ or ‘LSBFIRST’ depending on the native format of the
     machine running PSPP.

RRB

     PSPP extension to set the floating-point format used for reading
     data in RB format (*note Binary and Hexadecimal Numeric Formats::).
     The possibilities are:

     NATIVE
          The native format of the machine running PSPP.  Equivalent to
          either IDL or IDB.

     ISL
          32-bit IEEE 754 single-precision floating point, in
          little-endian byte order.

     ISB
          32-bit IEEE 754 single-precision floating point, in big-endian
          byte order.

     IDL
          64-bit IEEE 754 double-precision floating point, in
          little-endian byte order.

     IDB
          64-bit IEEE 754 double-precision floating point, in big-endian
          byte order.

     VF
          32-bit VAX F format, in VAX-endian byte order.

     VD
          64-bit VAX D format, in VAX-endian byte order.

     VG
          64-bit VAX G format, in VAX-endian byte order.

     ZS
          32-bit IBM Z architecture short format hexadecimal floating
          point, in big-endian byte order.

     ZL
          64-bit IBM Z architecture long format hexadecimal floating
          point, in big-endian byte order.

          Z architecture also supports IEEE 754 floating point.  The ZS
          and ZL formats are only for use with very old input files.
     The default is NATIVE.

   Interaction subcommands affect the way that PSPP interacts with an
online user.  The interaction subcommands are

MXERRS
     The maximum number of errors before PSPP halts processing of the
     current command file.  The default is 50.

MXWARNS
     The maximum number of warnings + errors before PSPP halts
     processing the current command file.  The special value of zero
     means that all warning situations should be ignored.  No warnings
     are issued, except a single initial warning advising you that
     warnings will not be given.  The default value is 100.

   Syntax execution subcommands control the way that PSPP commands
execute.  The syntax execution subcommands are

LOCALE
     Overrides the system locale for the purpose of reading and writing
     syntax and data files.  The argument should be a locale name in the
     general form ‘LANGUAGE_COUNTRY.ENCODING’, where LANGUAGE and
     COUNTRY are 2-character language and country abbreviations,
     respectively, and ENCODING is an IANA character set name.  Example
     locales are ‘en_US.UTF-8’ (UTF-8 encoded English as spoken in the
     United States) and ‘ja_JP.EUC-JP’ (EUC-JP encoded Japanese as
     spoken in Japan).

MXLOOPS

     The maximum number of iterations for an uncontrolled loop (*note
     LOOP::), and for any loop in the matrix language (*note Matrix LOOP
     and BREAK Commands::).  The default MAX_LOOPS is 40.

SEED
     The initial pseudo-random number seed.  Set it to a real number or
     to RANDOM, to obtain an initial seed from the current time of day.

UNDEFINED
     Currently not used.

FUZZBITS
     The maximum number of bits of errors in the least-significant
     places to accept for rounding up a value that is almost halfway
     between two possibilities for rounding with the RND operator (*note
     Miscellaneous Mathematics::).  The default FUZZBITS is 6.

SCALEMIN
     The minimum number of distinct valid values for PSPP to assume that
     a variable has a scale measurement level.  *Note Measurement
     Level::.

WORKSPACE
     The maximum amount of memory (in kilobytes) that PSPP uses to store
     data being processed.  If memory in excess of the workspace size is
     required, then PSPP starts to use temporary files to store the
     data.  Setting a higher value means that procedures run faster, but
     may cause other applications to run slower.  On platforms without
     virtual memory management, setting a very large workspace may cause
     PSPP to abort.

   Data output subcommands affect the format of output data.  These
subcommands are

CCA
CCB
CCC
CCD
CCE

     Set up custom currency formats.  *Note Custom Currency Formats::,
     for details.

DECIMAL
     The default ‘DOT’ setting causes the decimal point character to be
     ‘.’.  A setting of ‘COMMA’ causes the decimal point character to be
     ‘,’.

FORMAT
     Allows the default numeric input/output format to be specified.
     The default is F8.2.  *Note Input and Output Formats::.

LEADZERO

     Controls whether numbers with magnitude less than one are displayed
     with a zero before the decimal point.  For example, with ‘SET
     LEADZERO=OFF’, which is the default, one-half is shown as 0.5, and
     with ‘SET LEADZERO=ON’, it is shown as .5.  This setting affects
     only the ‘F’, ‘COMMA’, and ‘DOT’ formats.

MDISPLAY

     Controls how the ‘PRINT’ command within ‘MATRIX’...‘END MATRIX’
     outputs matrices.  With the default ‘TEXT’, ‘PRINT’ outputs
     matrices as text.  Change this setting to ‘TABLES’ to instead
     output matrices as pivot tables.  *Note Matrix PRINT Command::, for
     more information.

SMALL
     This controls how PSPP formats small numbers in pivot tables, in
     cases where PSPP does not otherwise have a well-defined format for
     the numbers.  When such a number has a magnitude less than the
     value set here, PSPP formats the number in scientific notation;
     otherwise, it formats it in standard notation.  The default is
     0.0001.  Set a value of 0 to disable scientific notation.

SUMMARY
     The ‘SUMMARY’ option sets the comment string which will appear in
     all generated tables until the next ‘SUMMARY’ is issued.  If the
     special value ‘NONE’ is specified, then no comment will appear.
     These comment strings can be seen in the graphical user interface
     by placing the pointer over the table.  If COMMENT contains any of
     the following substrings, they will be subsituted as follows:
     ‘\n’
          A line break.
     ‘)DATE’
          The current date in the form ‘dd-mmm-yyyy’
     ‘)ADATE’
          The current date in the form ‘mm/dd/yyyy’
     ‘)SDATE’
          The current date in the form ‘yyyy/mm/dd’
     ‘)EDATE’
          The current date in the form ‘dd.mm.yyyy’
     ‘)TIME’
          The current 12 hour clock time in the form ‘hh:mm:ss’
     ‘)ETIME’
          The current 24 hour clock time in the form ‘hh:mm:ss’

WIB

     PSPP extension to set the byte ordering (endianness) used for
     writing data in IB or PIB format (*note Binary and Hexadecimal
     Numeric Formats::).  In ‘MSBFIRST’ ordering, the most-significant
     byte appears at the left end of a IB or PIB field.  In ‘LSBFIRST’
     ordering, the least-significant byte appears at the left end.
     ‘VAX’ ordering is like ‘MSBFIRST’, except that each pair of bytes
     is in reverse order.  ‘NATIVE’, the default, is equivalent to
     ‘MSBFIRST’ or ‘LSBFIRST’ depending on the native format of the
     machine running PSPP.

WRB

     PSPP extension to set the floating-point format used for writing
     data in RB format (*note Binary and Hexadecimal Numeric Formats::).
     The choices are the same as ‘SET RIB’.  The default is ‘NATIVE’.

   In the PSPP text-based interface, the output routing subcommands
affect where output is sent.  The following values are allowed for each
of these subcommands:

OFF
NONE
     Discard this kind of output.

TERMINAL
     Write this output to the terminal, but not to listing files and
     other output devices.

LISTING
     Write this output to listing files and other output devices, but
     not to the terminal.

ON
BOTH
     Write this type of output to all output devices.

   These output routing subcommands are:

ERRORS
     Applies to error and warning messages.  The default is ‘BOTH’.

MESSAGES
     Applies to notes.  The default is ‘BOTH’.

PRINTBACK
     Determines whether the syntax used for input is printed back as
     part of the output.  The default is ‘NONE’.

RESULTS
     Applies to everything not in one of the above categories, such as
     the results of statistical procedures.  The default is ‘BOTH’.

   These subcommands have no effect on output in the PSPP GUI
environment.

   Output driver option subcommands affect output drivers’ settings.
These subcommands are

HEADERS
LENGTH
WIDTH
TNUMBERS
     The ‘TNUMBERS’ option sets the way in which values are displayed in
     output tables.  The valid settings are ‘VALUES’, ‘LABELS’ and
     ‘BOTH’.  If ‘TNUMBERS’ is set to ‘VALUES’, then all values are
     displayed with their literal value (which for a numeric value is a
     number and for a string value an alphanumeric string).  If
     ‘TNUMBERS’ is set to ‘LABELS’, then values are displayed using
     their assigned labels if any.  (*Note VALUE LABELS::.)  If the
     value has no label, then the literal value is used for display.  If
     ‘TNUMBERS’ is set to ‘BOTH’, then values are displayed with both
     their label (if any) and their literal value in parentheses.
TVARS
     The ‘TVARS’ option sets the way in which variables are displayed in
     output tables.  The valid settings are ‘NAMES’, ‘LABELS’ and
     ‘BOTH’.  If ‘TVARS’ is set to ‘NAMES’, then all variables are
     displayed using their names.  If ‘TVARS’ is set to ‘LABELS’, then
     variables are displayed using their label if one has been set.  If
     no label has been set, then the name is used.  (*Note VARIABLE
     LABELS::.)  If ‘TVARS’ is set to ‘BOTH’, then variables are
     displayed with both their label (if any) and their name in
     parentheses.
TLOOK
     The ‘TLOOK’ option sets the style used for subsequent table output.
     Specifying ‘NONE’ makes PSPP use the default built-in style.
     Otherwise, specifying FILE makes PSPP search for an ‘.stt’ or
     ‘.tlo’ file in the same way as specifying ‘--table-look=FILE’ the
     PSPP command line (*note Main Options::).

   These subcommands affect journaling, also called logging.  When
journaling is enabled, PSPP writes the commands that it executes, plus
any errors or other diagostics that it outputs, to a text file, called
the “journal” file.

   PSPP enables journaling by default when it runs interactively in a
terminal or in the PSPPIRE GUI. In the GUI, use Edit → Options... to
view or override the default location or to disable journaling.  From
syntax, use ‘SHOW JOURNAL’ to see the journal’s location and whether it
is enabled.

JOURNAL
LOG
     Specify ‘ON’ to enable the journal and ‘OFF’ to disable it.
     Specify a file name to set the name of the journal file.

   System file subcommands affect the default format of system files
produced by PSPP.  These subcommands are

SCOMPRESSION
     Whether system files created by ‘SAVE’ or ‘XSAVE’ are compressed by
     default.  The default is ‘ON’.

   Security subcommands affect the operations that commands are allowed
to perform.  The security subcommands are

SAFER
     Setting this option disables the following operations:

        • The ‘ERASE’ command.
        • The ‘HOST’ command.
        • The ‘PERMISSIONS’ command.
        • Pipes (file names beginning or ending with ‘|’).

     Be aware that this setting does not guarantee safety (commands can
     still overwrite files, for instance) but it is an improvement.
     When set, this setting cannot be reset during the same session, for
     obvious security reasons.

LOCALE
     This item is used to set the default character encoding.  The
     encoding may be specified either as an encoding name or alias (see
     <http://www.iana.org/assignments/character-sets>), or as a locale
     name.  If given as a locale name, only the character encoding of
     the locale is relevant.

     System files written by PSPP use this encoding.  System files read
     by PSPP, for which the encoding is unknown, are interpreted using
     this encoding.

     The full list of valid encodings and locale names/alias are
     operating system dependent.  The following are all examples of
     acceptable syntax on common GNU/Linux systems.
          SET LOCALE='iso-8859-1'.

          SET LOCALE='ru_RU.cp1251'.

          SET LOCALE='japanese'.

     Contrary to intuition, this command does not affect any aspect of
     the system’s locale.

   The following subcommands affect the interpretation of macros.

MEXPAND
     Controls whether macros are expanded.  The default is ON.

MPRINT
     Controls whether the expansion of macros is included in output.
     This is separate from whether command syntax in general is included
     in output.  The default is OFF.

MITERATE
     Limits the number of iterations executed in ‘!DO’ loops within
     macros.  This does not affect other language constructs such as
     ‘LOOP’.  This must be set to a positive integer.  The default is
     1000.

MNEST
     Limits the number of levels of nested macro expansions.  This must
     be set to a positive integer.  The default is 50.

   The following subcommands are not yet implemented, but PSPP accepts
them and ignores the settings.

BASETEXTDIRECTION
BLOCK
BOX
CACHE
CELLSBREAK
COMPRESSION
CMPTRANS
HEADER


File: pspp.info,  Node: SHOW,  Next: SUBTITLE,  Prev: SET,  Up: Utilities

17.21 SHOW
==========

     SHOW
             [ALL]
             [BLANKS]
             [CC]
             [CCA]
             [CCB]
             [CCC]
             [CCD]
             [CCE]
             [COPYING]
             [DECIMAL]
             [DIRECTORY]
             [ENVIRONMENT]
             [FORMAT]
             [FUZZBITS]
             [LENGTH]
             [MEXPAND]
             [MPRINT]
             [MITERATE]
             [MNEST]
             [MXERRS]
             [MXLOOPS]
             [MXWARNS]
             [N]
             [SCOMPRESSION]
             [SYSTEM]
             [TEMPDIR]
             [UNDEFINED]
             [VERSION]
             [WARRANTY]
             [WEIGHT]
             [WIDTH]

   ‘SHOW’ can be used to display the current state of PSPP’s execution
parameters.  Parameters that can be changed using ‘SET’ (*note SET::),
can be examined using ‘SHOW’ using the subcommand with the same name.
‘SHOW’ supports the following additional subcommands:

‘ALL’
     Show all settings.
‘CC’
     Show all custom currency settings (‘CCA’ through ‘CCE’).
‘DIRECTORY’
     Shows the current working directory.
‘ENVIRONMENT’
     Shows the operating system details.
‘N’
     Reports the number of cases in the active dataset.  The reported
     number is not weighted.  If no dataset is defined, then ‘Unknown’
     is reported.
‘SYSTEM’
     Shows information about how PSPP was built.  This information is
     useful in bug reports.  *Note Bugs::, for details.
‘TEMPDIR’
     Shows the path of the directory where temporary files are stored.
‘VERSION’
     Shows the version of this installation of PSPP.
‘WARRANTY’
     Show details of the lack of warranty for PSPP.
‘COPYING’ / ‘LICENSE’
     Display the terms of PSPP’s copyright licence (*note License::).

   Specifying ‘SHOW’ without any subcommands is equivalent to ‘SHOW
ALL’.


File: pspp.info,  Node: SUBTITLE,  Next: TITLE,  Prev: SHOW,  Up: Utilities

17.22 SUBTITLE
==============

     SUBTITLE ’SUBTITLE_STRING’.
       or
     SUBTITLE SUBTITLE_STRING.

   ‘SUBTITLE’ provides a subtitle to a particular PSPP run.  This
subtitle appears at the top of each output page below the title, if
headers are enabled on the output device.

   Specify a subtitle as a string in quotes.  The alternate syntax that
did not require quotes is now obsolete.  If it is used then the subtitle
is converted to all uppercase.


File: pspp.info,  Node: TITLE,  Prev: SUBTITLE,  Up: Utilities

17.23 TITLE
===========

     TITLE ’TITLE_STRING’.
       or
     TITLE TITLE_STRING.

   ‘TITLE’ provides a title to a particular PSPP run.  This title
appears at the top of each output page, if headers are enabled on the
output device.

   Specify a title as a string in quotes.  The alternate syntax that did
not require quotes is now obsolete.  If it is used then the title is
converted to all uppercase.


File: pspp.info,  Node: Invoking pspp-convert,  Next: Invoking pspp-output,  Prev: Utilities,  Up: Top

18 Invoking ‘pspp-convert’
**************************

‘pspp-convert’ is a command-line utility accompanying PSPP.  It reads an
SPSS or SPSS/PC+ system file or SPSS portable file or encrypted SPSS
syntax file INPUT and writes a copy of it to another OUTPUT in a
different format.  Synopsis:

     pspp-convert [OPTIONS] INPUT OUTPUT

     pspp-convert --help

     pspp-convert --version

   The format of INPUT is automatically detected, when possible.  The
character encoding of old SPSS system files cannot always be guessed
correctly, and SPSS/PC+ system files do not include any indication of
their encoding.  Use ‘-e ENCODING’ to specify the encoding in this case.

   By default, the intended format for OUTPUT is inferred based on its
extension:

‘csv’
‘txt’
     Comma-separated value.  Each value is formatted according to its
     variable’s print format.  The first line in the file contains
     variable names.

‘sav’
‘sys’
     SPSS system file.

‘por’
     SPSS portable file.

‘sps’
     SPSS syntax file.  (Only encrypted syntax files may be converted to
     this format.)

   ‘pspp-convert’ can convert most input formats to most output formats.
Encrypted SPSS file formats are exceptions: if the input file is in an
encrypted format, then the output file will be the same format
(decrypted).  To decrypt such a file, specify the encrypted file as
INPUT.  The output will be the equivalent plaintext file.  Options for
the output format are ignored in this case.

   The password for encrypted files can be specified a few different
ways.  If the password is known, use the ‘-p’ option (documented below)
or allow ‘pspp-convert’ to prompt for it.  If the password is unknown,
use the ‘-a’ and ‘-l’ options to specify how to search for it, or
‘--password-list’ to specify a file of passwords to try.

   Use ‘-O FORMAT’ to override the inferred format or to specify the
format for unrecognized extensions.

   ‘pspp-convert’ accepts the following general options:

‘-O FORMAT’
‘--output-format=FORMAT’
     Sets the output format, where FORMAT is one of the extensions
     listed above, e.g.: ‘-O csv’.  Use ‘--help’ to list the supported
     output formats.

‘-c MAXCASES’
‘--cases=MAXCASES’
     By default, all cases are copied from INPUT to OUTPUT.  Specifying
     this option to limit the number of cases written to OUTPUT to
     MAXCASES.

‘-e CHARSET’
‘--encoding=CHARSET’
     Overrides the encoding in which character strings in INPUT are
     interpreted.  This option is necessary because old SPSS system
     files, and SPSS/PC+ system files, do not self-identify their
     encoding.

‘-k VARIABLE...’
‘--keep=VARIABLE...’
     By default, ‘pspp-convert’ includes all the variables from the
     input file.  Use this option to list specific variables to include;
     any variables not listed will be dropped.  The variables in the
     output file will also be reordered into the given order.  The
     variable list may use ‘TO’ in the same way as in PSPP syntax, e.g.
     if the dictionary contains consecutive variables ‘a’, ‘b’, ‘c’, and
     ‘d’, then ‘--keep='a to d'’ will include all of them (and no
     others).

‘-d VARIABLE...’
‘--drop=VARIABLE...’
     Drops the specified variables from the output.

     When ‘--keep’ and ‘--drop’ are used together, ‘--keep’ is processed
     first.

‘-h’
‘--help’
     Prints a usage message on stdout and exits.

‘-v’
‘--version’
     Prints version information on stdout and exits.

   The following options affect CSV output:

‘--recode’
     By default, ‘pspp-convert’ writes user-missing values to CSV output
     files as their regular values.  With this option, ‘pspp-convert’
     recodes them to system-missing values (which are written as a
     single space).

‘--no-var-names’
     By default, ‘pspp-convert’ writes the variable names as the first
     line of output.  With this option, ‘pspp-convert’ omits this line.

‘--labels’
     By default, ‘pspp-convert’ writes variables’ values to CSV output
     files.  With this option, ‘pspp-convert’ writes value labels.

‘--print-formats’
     By default, ‘pspp-convert’ writes numeric variables as plain
     numbers.  This option makes ‘pspp-convert’ honor variables’ print
     formats.

‘--decimal=DECIMAL’
     This option sets the character used as a decimal point in output.
     The default is ‘.’.

‘--delimiter=DELIMITER’
     This option sets the character used to separate fields in output.
     The default is ‘,’, unless the decimal point is ‘,’, in which case
     ‘;’ is used.

‘--qualifier=QUALIFIER’
     The option sets the character used to quote fields that contain the
     delimiter.  The default is ‘"’.

   The following options specify how to obtain the password for
encrypted files:

‘-p PASSWORD’
‘--password=PASSWORD’
     Specifies the password to use to decrypt an encrypted SPSS system
     file or syntax file.  If this option is not specified,
     ‘pspp-convert’ will prompt interactively for the password as
     necessary.

     Be aware that command-line options, including passwords, may be
     visible to other users on multiuser systems.

     When used with ‘-a’ (or ‘--password-alphabet’) and ‘-l’ (or
     ‘--password-length’), this option specifies the starting point for
     the search.  This can be used to restart a search that was
     interrupted.

‘-a ALPHABET’
‘--password-alphabet=ALPHABET’
     Specifies the alphabet of symbols over which to search for an
     encrypted file’s password.  ALPHABET may include individual
     characters and ranges delimited by ‘-’.  For example, ‘-a a-z’
     searches lowercase letters, ‘-a A-Z0-9’ searches uppercase letters
     and digits, and ‘-a ' -~'’ searches all printable ASCII characters.

‘-l MAX-LENGTH’
‘--password-length=MAX-LENGTH’
     Specifies the maximum length of the passwords to try.

‘--password-list=FILE’
     Specifies a file to read containing a list of passwords to try, one
     per line.  If FILE is ‘-’, reads from stdin.


File: pspp.info,  Node: Invoking pspp-output,  Next: Invoking pspp-dump-sav,  Prev: Invoking pspp-convert,  Up: Top

19 Invoking ‘pspp-output’
*************************

‘pspp-output’ is a command-line utility accompanying PSPP.  It supports
multiple operations on SPSS viewer or ‘.spv’ files, here called SPV
files.  SPSS 16 and later writes SPV files to represent the contents of
its output editor.

   SPSS 15 and earlier versions instead use ‘.spo’ files.  ‘pspp-output’
does not support this format.

   ‘pspp-options’ may be invoked in the following ways:

     pspp-output detect FILE

     pspp-output [OPTIONS] dir FILE

     pspp-output [OPTIONS] convert SOURCE DESTINATION

     pspp-output [OPTIONS] get-table-look SOURCE DESTINATION

     pspp-output [OPTIONS] convert-table-look SOURCE DESTINATION

     pspp-output --help

     pspp-output --version

   Each of these forms is documented separately below.  ‘pspp-output’
also has several undocumented command forms that developers may find
useful for debugging.

* Menu:

* The pspp-output detect Command::
* The pspp-output dir Command::
* The pspp-output convert Command::
* The pspp-output get-table-look Command::
* The pspp-output convert-table-look Command::
* Input Selection Options::


File: pspp.info,  Node: The pspp-output detect Command,  Next: The pspp-output dir Command,  Up: Invoking pspp-output

19.1 The ‘detect’ Command
=========================

     pspp-output detect FILE

   When FILE is an SPV file, ‘pspp-output’ exits successfully without
outputting anything.  When FILE is not an SPV file or some other error
occurs, ‘pspp-output’ prints an error message and exits with a failure
indication.


File: pspp.info,  Node: The pspp-output dir Command,  Next: The pspp-output convert Command,  Prev: The pspp-output detect Command,  Up: Invoking pspp-output

19.2 The ‘dir’ Command
======================

     pspp-output [OPTIONS] dir FILE

   Prints on stdout a table of contents for SPV file FILE.  By default,
this table lists every object in the file, except for hidden objects.
*Note Input Selection Options::, for information on the options
available to select a subset of objects.

   The following additional option for ‘dir’ is intended mainly for use
by PSPP developers:

‘--member-names’
     Also show the names of the Zip members associated with each object.


File: pspp.info,  Node: The pspp-output convert Command,  Next: The pspp-output get-table-look Command,  Prev: The pspp-output dir Command,  Up: Invoking pspp-output

19.3 The ‘convert’ Command
==========================

     pspp-output [OPTIONS] convert SOURCE DESTINATION

   Reads SPV file SOURCE and converts it to another format, writing the
output to DESTINATION.

   By default, the intended format for DESTINATION is inferred based on
its extension, in the same way that the ‘pspp’ program does for its
output files.  *Note Invoking PSPP::, for details.

   *Note Input Selection Options::, for information on the options
available to select a subset of objects to include in the output.  The
following additional options are accepted:

‘-O format=FORMAT’
     Overrides the format inferred from the output file’s extension.
     Use ‘--help’ to list the available formats.  *Note Invoking PSPP::,
     for details of the available output formats.

‘-O OPTION=VALUE’
     Sets an option for the output file format.  *Note Invoking PSPP::,
     for details of the available output options.

‘-F’
‘--force’
     By default, if the source is corrupt or otherwise cannot be
     processed, the destination is not written.  With ‘-F’ or ‘--force’,
     the destination is written as best it can, even with errors.

‘--table-look=FILE’
     Reads a table style from FILE and applies it to all of the output
     tables.  The file should be a TableLook ‘.stt’ or ‘.tlo’ file.

‘--use-page-setup’
     By default, the ‘convert’ command uses the default page setup (for
     example, page size and margins) for DESTINATION, or the one
     specified with ‘-O’ options, if any.  Specify this option to ignore
     these sources of page setup in favor of the one embedded in the
     SPV, if any.


File: pspp.info,  Node: The pspp-output get-table-look Command,  Next: The pspp-output convert-table-look Command,  Prev: The pspp-output convert Command,  Up: Invoking pspp-output

19.4 The ‘get-table-look’ Command
=================================

     pspp-output [OPTIONS] get-table-look SOURCE DESTINATION

   Reads SPV file SOURCE, applies any selection options (*note Input
Selection Options::), picks the first table from the selected object,
extracts the TableLook from that table, and writes it to DESTINATION
(typically with an ‘.stt’ extension) in the TableLook XML format.

   Use ‘-’ for SOURCE to instead write the default look to DESTINATION.

   The user may use the TableLook file to change the style of tables in
other files, by passing it to the ‘--table-look’ option on the ‘convert’
command.


File: pspp.info,  Node: The pspp-output convert-table-look Command,  Next: Input Selection Options,  Prev: The pspp-output get-table-look Command,  Up: Invoking pspp-output

19.5 The ‘convert-table-look’ Command
=====================================

     pspp-output [OPTIONS] convert-table-look SOURCE DESTINATION

   Reads ‘.stt’ or ‘.tlo’ file SOURCE, and writes it back to DESTINATION
(typically with an ‘.stt’ extension) in the TableLook XML format.  This
is useful for converting a TableLook ‘.tlo’ file from SPSS 15 or earlier
into the newer ‘.stt’ format.


File: pspp.info,  Node: Input Selection Options,  Prev: The pspp-output convert-table-look Command,  Up: Invoking pspp-output

19.6 Input Selection Options
============================

The ‘dir’ and ‘convert’ commands, by default, operate on all of the
objects in the source SPV file, except for objects that are not visible
in the output viewer window.  The user may specify these options to
select a subset of the input objects.  When multiple options are used,
only objects that satisfy all of them are selected:

‘--select=[^]CLASS...’
     Include only objects of the given CLASS; with leading ‘^’, include
     only objects not in the class.  Use commas to separate multiple
     classes.  The supported classes are:

          ‘charts headings logs models tables texts trees warnings
          outlineheaders pagetitle notes unknown other’

     Use ‘--select=help’ to print this list of classes.

‘--commands=[^]COMMAND...’
‘--subtypes=[^]SUBTYPE...’
‘--labels=[^]LABEL...’
     Include only objects with the specified COMMAND, SUBTYPE, or LABEL.
     With a leading ‘^’, include only the objects that do not match.
     Multiple values may be specified separated by commas.  An asterisk
     at the end of a value acts as a wildcard.

     The ‘--command’ option matches command identifiers, case
     insensitively.  All of the objects produced by a single command use
     the same, unique command identifier.  Command identifiers are
     always in English regardless of the language used for output.  They
     often differ from the command name in PSPP syntax.  Use the
     ‘pspp-output’ program’s ‘dir’ command to print command identifiers
     in particular output.

     The ‘--subtypes’ option matches particular tables within a command,
     case insensitively.  Subtypes are not necessarily unique: two
     commands that produce similar output tables may use the same
     subtype.  Subtypes are always in English and ‘dir’ will print them.

     The ‘--labels’ option matches the labels in table output (that is,
     the table titles).  Labels are affected by the output language,
     variable names and labels, split file settings, and other factors.

‘--nth-commands=N...’
     Include only objects from the Nth command that matches ‘--command’
     (or the Nth command overall if ‘--command’ is not specified), where
     N is 1 for the first command, 2 for the second, and so on.

‘--instances=INSTANCE...’
     Include the specified INSTANCE of an object that matches the other
     criteria within a single command.  The INSTANCE may be a number (1
     for the first instance, 2 for the second, and so on) or ‘last’ for
     the last instance.

‘--show-hidden’
     Include hidden output objects in the output.  By default, they are
     excluded.

‘--or’
     Separates two sets of selection options.  Objects selected by
     either set of options are included in the output.

   The following additional input selection options are intended mainly
for use by PSPP developers:

‘--errors’
     Include only objects that cause an error when read.  With the
     ‘convert’ command, this is most useful in conjunction with the
     ‘--force’ option.

‘--members=MEMBER...’
     Include only the objects that include a listed Zip file MEMBER.
     More than one name may be included, comma-separated.  The members
     in an SPV file may be listed with the ‘dir’ command by adding the
     ‘--show-members’ option or with the ‘zipinfo’ program included with
     many operating systems.  Error messages that ‘pspp-output’ prints
     when it reads SPV files also often include member names.

‘--member-names’
     Displays the name of the Zip member or members associated with each
     object just above the object itself.


File: pspp.info,  Node: Invoking pspp-dump-sav,  Next: Not Implemented,  Prev: Invoking pspp-output,  Up: Top

20 Invoking ‘pspp-dump-sav’
***************************

‘pspp-dump-sav’ is a command-line utility accompanying PSPP.  It is not
installed by default, so it may be missing from your PSPP installation.
It reads one or more SPSS system files and prints their contents.  The
output format is useful for debugging system file readers and writers
and for discovering how to interpret unknown or poorly understood
records.  End users may find the output useful for providing the PSPP
developers information about system files that PSPP does not accurately
read.

   Synopsis:

     pspp-dump-sav [-d[MAXCASES] | --data[=MAXCASES]] FILE...

     pspp-dump-sav --help | -h

     pspp-dump-sav --version | -v

   The following options are accepted:

-d[MAXCASES]
--data[=MAXCASES]
     By default, ‘pspp-dump-sav’ does not print any of the data in a
     system file, only the file headers.  Specify this option to print
     the data as well.  If MAXCASES is specified, then it limits the
     number of cases printed.

-h
--help
     Prints a usage message on stdout and exits.

-v
--version
     Prints version information on stdout and exits.

   Some errors that prevent files from being interpreted successfully
cause ‘pspp-dump-sav’ to exit without reading any additional files given
on the command line.


File: pspp.info,  Node: Not Implemented,  Next: Bugs,  Prev: Invoking pspp-dump-sav,  Up: Top

21 Not Implemented
******************

This chapter lists parts of the PSPP language that are not yet
implemented.

‘2SLS’
     Two stage least squares regression

‘ACF’
     Autocorrelation function

‘ALSCAL’
     Multidimensional scaling

‘ANACOR’
     Correspondence analysis

‘ANOVA’
     Factorial analysis of variance

‘CASEPLOT’
     Plot time series

‘CASESTOVARS’
     Restructure complex data

‘CATPCA’
     Categorical principle components analysis

‘CATREG’
     Categorical regression

‘CCF’
     Time series cross correlation

‘CLEAR TRANSFORMATIONS’
     Clears transformations from active dataset

‘CLUSTER’
     Hierarchical clustering

‘CONJOINT’
     Analyse full concept data

‘CORRESPONDENCE’
     Show correspondence

‘COXREG’
     Cox proportional hazards regression

‘CREATE’
     Create time series data

‘CSDESCRIPTIVES’
     Complex samples descriptives

‘CSGLM’
     Complex samples GLM

‘CSLOGISTIC’
     Complex samples logistic regression

‘CSPLAN’
     Complex samples design

‘CSSELECT’
     Select complex samples

‘CSTABULATE’
     Tabulate complex samples

‘CURVEFIT’
     Fit curve to line plot

‘DATE’
     Create time series data

‘DETECTANOMALY’
     Find unusual cases

‘DISCRIMINANT’
     Linear discriminant analysis

‘EDIT’
     obsolete

‘END FILE TYPE’
     Ends complex data input

‘FILE TYPE’
     Complex data input

‘FIT’
     Goodness of Fit

‘GENLOG’
     Categorical model fitting

‘GET TRANSLATE’
     Read other file formats

‘GGRAPH’
     Custom defined graphs

‘HILOGLINEAR’
     Hierarchical loglinear models

‘HOMALS’
     Homogeneity analysis

‘IGRAPH’
     Interactive graphs

‘INFO’
     Local Documentation

‘KEYED DATA LIST’
     Read nonsequential data

‘KM’
     Kaplan-Meier

‘LOGLINEAR’
     General model fitting

‘MANOVA’
     Multivariate analysis of variance

‘MAPS’
     Geographical display

‘MIXED’
     Mixed linear models

‘MODEL CLOSE’
     Close server connection

‘MODEL HANDLE’
     Define server connection

‘MODEL LIST’
     Show existing models

‘MODEL NAME’
     Specify model label

‘MULTIPLE CORRESPONDENCE’
     Multiple correspondence analysis

‘MULT RESPONSE’
     Multiple response analysis

‘MVA’
     Missing value analysis

‘NAIVEBAYES’
     Small sample bayesian prediction

‘NLR’
     Non Linear Regression

‘NOMREG’
     Multinomial logistic regression

‘NONPAR CORR’
     Nonparametric correlation

‘NUMBERED’

‘OLAP CUBES’
     On-line analytical processing

‘OMS’
     Output management

‘ORTHOPLAN’
     Orthogonal effects design

‘OVERALS’
     Nonlinear canonical correlation

‘PACF’
     Partial autocorrelation

‘PARTIAL CORR’
     Partial correlation

‘PLANCARDS’
     Conjoint analysis planning

‘PLUM’
     Estimate ordinal regression models

‘POINT’
     Marker in keyed file

‘PPLOT’
     Plot time series variables

‘PREDICT’
     Specify forecast period

‘PREFSCAL’
     Multidimensional unfolding

‘PRINCALS’
     PCA by alternating least squares

‘PROBIT’
     Probit analysis

‘PROCEDURE OUTPUT’
     Specify output file

‘PROXIMITIES’
     Pairwise similarity

‘PROXSCAL’
     Multidimensional scaling of proximity data

‘RATIO STATISTICS’
     Descriptives of ratios

‘READ MODEL’
     Read new model

‘RECORD TYPE’
     Defines a type of record within FILE TYPE

‘REFORMAT’
     Read obsolete files

‘REPEATING DATA’
     Specify multiple cases per input record

‘REPORT’
     Pretty print working file

‘RMV’
     Replace missing values

‘SCRIPT’
     Run script file

‘SEASON’
     Estimate seasonal factors

‘SELECTPRED’
     Select predictor variables

‘SPCHART’
     Plot control charts

‘SPECTRA’
     Plot spectral density

‘STEMLEAF’
     Plot stem-and-leaf display

‘SUMMARIZE’
     Univariate statistics

‘SURVIVAL’
     Survival analysis

‘TDISPLAY’
     Display active models

‘TREE’
     Create classification tree

‘TSAPPLY’
     Apply time series model

‘TSET’
     Set time sequence variables

‘TSHOW’
     Show time sequence variables

‘TSMODEL’
     Estimate time series model

‘TSPLOT’
     Plot time sequence variables

‘TWOSTEP CLUSTER’
     Cluster observations

‘UNIANOVA’
     Univariate analysis

‘UNNUMBERED’
     obsolete

‘VALIDATEDATA’
     Identify suspicious cases

‘VARCOMP’
     Estimate variance

‘VARSTOCASES’
     Restructure complex data

‘VERIFY’
     Report time series

‘WLS’
     Weighted least squares regression

‘XGRAPH’
     High resolution charts


File: pspp.info,  Node: Bugs,  Next: Function Index,  Prev: Not Implemented,  Up: Top

22 Bugs
*******

Occasionally you may encounter a bug in PSPP.

   If you believe you have found a bug, please make sure that it really
is a bug.  Sometimes, what may appear to be a bug, turns out to be a
misunderstanding of how to use the program.  If you are unsure, ask for
advice on the pspp-users mailing list.  Information about the mailing
list is at <http://lists.gnu.org/mailman/listinfo/pspp-users>.

   It is also valuable to try the newest version of PSPP, since the
problem may have already been fixed.  You can always find the newest
version of PSPP by visiting the PSPP website
(https://www.gnu.org/s/pspp).  You might have obtained PSPP from a
downstream packager, such as a GNU/Linux distribution; if your
downstream package is not up-to-date, please ask the distributor to
update to the newest version.

   If the problem persists in the up-to-date version, check to see if it
has already been reported.  Reported issues are listed at
<http://savannah.gnu.org/bugs/?group=pspp>.  If it has already been
reported, you might consider adding a comment with additional
information or even just to mention that you are also experiencing the
problem, since the PSPP developers are often inclined to work on issues
that are important to a large number of users.

   For known issues in individual language features, see the relevant
section in *note Language::.

   If the problem exists in a recent version and it has not already been
reported, then please report it.

22.1 How to report bugs
=======================

The best way to send a bug report is using the web page at
<http://savannah.gnu.org/bugs/?group=pspp>.  Alternatively, bug reports
may be sent by email to <bug-gnu-pspp@gnu.org>.

   A high-quality bug report allows the developers to understand,
reproduce, and ultimately fix the problem.  We recommend including the
following:

   • The version of PSPP in which you encountered the problem.  It also
     often helps to know some information about how PSPP was built.

     With PSPP command syntax, ‘SHOW SYSTEM.’ will output everything we
     ordinarily need.  In the PSPPIRE GUI, Help → System Info produces
     the same output.

   • The operating system and type of computer on which it is running.

   • A sample of the syntax which causes the problem or, if it is a user
     interface problem, the sequence of steps required to reproduce it.
     Screenshots can be helpful for reporting bugs in the graphical user
     interface, especially since GUI bugs can arise on some systems but
     not others, but they do not usually help fixing other kinds of
     bugs.

   • A description of what you think is wrong: What happened that you
     didn’t expect, and what did you expect to happen?  Include any
     error messages that PSPP output.

   Here is one example of a bug report that includes all of the elements
above:

     I'm running PSPP on a system where SHOW SYSTEM.  outputs the
     following:


      [image src="pspp-figures/show-system.png" text="                   System Information
+----------------+------------------------------------+
|Version         |GNU pspp 2.0.1                      |
|Host System     |x86_64-pc-linux-gnu                 |
|Build System    |x86_64-pc-linux-gnu                 |
|Locale Directory|//share/locale                      |
|Journal File    |/home/blp/.local/state/pspp/pspp.jnl|
|Compiler Version|13.2.1 20231205 (Red Hat 13.2.1-6)  |
+----------------+------------------------------------+" ]


     The bug I'm seeing is that executing the following syntax:

      DATA LIST FREE /x *.
      BEGIN DATA.
      1 2 3
      END DATA.
      LIST.

     results in:

      4
      5
      6

     but I think the output should be:

      1
      2
      3

   The following bug report, on the other hand, does not provide enough
information for PSPP developers to understand the problem.  This means
that the developers cannot identify or fix the problem without
additional rounds of questions, which is more work for both the reporter
and the developer:

     I downloaded the latest version of PSPP and entered a sequence of numbers,
     but when I analyse them it gives the wrong output.

   PSPP developers value all users’ feedback, but cannot promise an
immediate response.  The bug reporting is not a consultancy or support
service, although you can make private arrangements for such services.
Since PSPP is free software, consultants have access to the information
they need to provide such support.

   For general enquiries or help, please use the pspp-users mailing list
(http://lists.gnu.org/mailman/listinfo/pspp-users) instead of the bug
mailing list or bug tracker.

   The PSPP bug tracker and bug reporting mailing list are public.  To
privately report a security vulnerability in GNU PSPP, please send your
report to the closed mailing list <pspp-security@gnu.org>.  The PSPP
developers will help you assess your report and fix problems prior to
public disclosure.


File: pspp.info,  Node: Function Index,  Next: Command Index,  Prev: Bugs,  Up: Top

23 Function Index
*****************

 [index ]
* Menu:

* !BLANKS:                               Macro Functions.     (line  30)
* !CONCAT:                               Macro Functions.     (line  44)
* !EVAL:                                 Macro Functions.     (line  70)
* !HEAD:                                 Macro Functions.     (line  92)
* !INDEX:                                Macro Functions.     (line 107)
* !LENGTH:                               Macro Functions.     (line 118)
* !NULL:                                 Macro Functions.     (line 135)
* !QUOTE:                                Macro Functions.     (line 141)
* !SUBSTR:                               Macro Functions.     (line 171)
* !TAIL:                                 Macro Functions.     (line  93)
* !UNQUOTE:                              Macro Functions.     (line 142)
* !UPCASE:                               Macro Functions.     (line 187)
* (VARIABLE):                            Miscellaneous Functions.
                                                              (line  41)
* ABS:                                   Miscellaneous Mathematics.
                                                              (line   9)
* ABS <1>:                               Matrix Elementwise Functions.
                                                              (line  10)
* ACOS:                                  Trigonometry.        (line  10)
* ALL:                                   Matrix Logical Functions.
                                                              (line   6)
* ANY:                                   Set Membership.      (line  14)
* ANY <1>:                               Matrix Logical Functions.
                                                              (line  15)
* ARCOS:                                 Trigonometry.        (line   9)
* ARSIN:                                 Trigonometry.        (line  15)
* ARSIN <1>:                             Matrix Elementwise Functions.
                                                              (line  15)
* ARTAN:                                 Trigonometry.        (line  20)
* ARTAN <1>:                             Matrix Elementwise Functions.
                                                              (line  16)
* ASIN:                                  Trigonometry.        (line  16)
* ATAN:                                  Trigonometry.        (line  21)
* BLOCK:                                 Matrix Construction Functions.
                                                              (line   6)
* CDF.BERNOULLI:                         Discrete Distributions.
                                                              (line   9)
* CDF.BETA:                              Continuous Distributions.
                                                              (line   9)
* CDF.BINOM:                             Discrete Distributions.
                                                              (line  15)
* CDF.BVNOR:                             Continuous Distributions.
                                                              (line  19)
* CDF.CAUCHY:                            Continuous Distributions.
                                                              (line  25)
* CDF.CHISQ:                             Continuous Distributions.
                                                              (line  31)
* CDF.EXP:                               Continuous Distributions.
                                                              (line  41)
* CDF.F:                                 Continuous Distributions.
                                                              (line  55)
* CDF.GAMMA:                             Continuous Distributions.
                                                              (line  65)
* CDF.GEOM:                              Discrete Distributions.
                                                              (line  21)
* CDF.HYPER:                             Discrete Distributions.
                                                              (line  27)
* CDF.LAPLACE:                           Continuous Distributions.
                                                              (line  76)
* CDF.LNORMAL:                           Continuous Distributions.
                                                              (line  99)
* CDF.LOGISTIC:                          Continuous Distributions.
                                                              (line  92)
* CDF.NEGBIN:                            Discrete Distributions.
                                                              (line  39)
* CDF.NORMAL:                            Continuous Distributions.
                                                              (line 106)
* CDF.PARETO:                            Continuous Distributions.
                                                              (line 129)
* CDF.POISSON:                           Discrete Distributions.
                                                              (line  46)
* CDF.RAYLEIGH:                          Continuous Distributions.
                                                              (line 136)
* CDF.T:                                 Continuous Distributions.
                                                              (line 149)
* CDF.T1G:                               Continuous Distributions.
                                                              (line 157)
* CDF.T2G:                               Continuous Distributions.
                                                              (line 163)
* CDF.UNIFORM:                           Continuous Distributions.
                                                              (line 169)
* CDF.WEIBULL:                           Continuous Distributions.
                                                              (line 180)
* CDFNORM:                               Continuous Distributions.
                                                              (line 113)
* CFVAR:                                 Statistical Functions.
                                                              (line  24)
* CHOL:                                  Matrix Algebra Functions.
                                                              (line   6)
* CMAX:                                  Matrix Minimum and Maximum and Sum Functions.
                                                              (line   7)
* CMIN:                                  Matrix Minimum and Maximum and Sum Functions.
                                                              (line   6)
* CONCAT:                                String Functions.    (line   8)
* COS:                                   Trigonometry.        (line  24)
* COS <1>:                               Matrix Elementwise Functions.
                                                              (line  27)
* CSSQ:                                  Matrix Minimum and Maximum and Sum Functions.
                                                              (line   9)
* CSUM:                                  Matrix Minimum and Maximum and Sum Functions.
                                                              (line   8)
* CTIME.DAYS:                            Time Extraction.     (line   9)
* CTIME.HOURS:                           Time Extraction.     (line  12)
* CTIME.MINUTES:                         Time Extraction.     (line  15)
* CTIME.SECONDS:                         Time Extraction.     (line  18)
* DATE.DMY:                              Date Construction.   (line  39)
* DATE.MDY:                              Date Construction.   (line  40)
* DATE.MOYR:                             Date Construction.   (line  44)
* DATE.QYR:                              Date Construction.   (line  48)
* DATE.WKYR:                             Date Construction.   (line  52)
* DATE.YRDAY:                            Date Construction.   (line  56)
* DATEDIFF:                              Time and Date Arithmetic.
                                                              (line  24)
* DATESUM:                               Time and Date Arithmetic.
                                                              (line  38)
* DESIGN:                                Matrix Algebra Functions.
                                                              (line  15)
* DET:                                   Matrix Algebra Functions.
                                                              (line  31)
* DIAG:                                  Matrix Property Functions.
                                                              (line  16)
* EOF:                                   Matrix EOF Function. (line   8)
* EVAL:                                  Matrix Algebra Functions.
                                                              (line  36)
* EXP:                                   Mathematics.         (line   9)
* EXP <1>:                               Matrix Elementwise Functions.
                                                              (line  35)
* GINV:                                  Matrix Algebra Functions.
                                                              (line  45)
* GRADE:                                 Matrix Rank Ordering Functions.
                                                              (line  15)
* GSCH:                                  Matrix Algebra Functions.
                                                              (line  52)
* IDENT:                                 Matrix Construction Functions.
                                                              (line  21)
* IDENT <1>:                             Matrix Construction Functions.
                                                              (line  22)
* IDF.BETA:                              Continuous Distributions.
                                                              (line  10)
* IDF.CAUCHY:                            Continuous Distributions.
                                                              (line  26)
* IDF.CHISQ:                             Continuous Distributions.
                                                              (line  33)
* IDF.EXP:                               Continuous Distributions.
                                                              (line  42)
* IDF.F:                                 Continuous Distributions.
                                                              (line  57)
* IDF.GAMMA:                             Continuous Distributions.
                                                              (line  66)
* IDF.LAPLACE:                           Continuous Distributions.
                                                              (line  77)
* IDF.LNORMAL:                           Continuous Distributions.
                                                              (line 100)
* IDF.LOGISTIC:                          Continuous Distributions.
                                                              (line  93)
* IDF.NORMAL:                            Continuous Distributions.
                                                              (line 107)
* IDF.PARETO:                            Continuous Distributions.
                                                              (line 130)
* IDF.RAYLEIGH:                          Continuous Distributions.
                                                              (line 137)
* IDF.T:                                 Continuous Distributions.
                                                              (line 150)
* IDF.T1G:                               Continuous Distributions.
                                                              (line 158)
* IDF.T2G:                               Continuous Distributions.
                                                              (line 164)
* IDF.UNIFORM:                           Continuous Distributions.
                                                              (line 170)
* IDF.WEIBULL:                           Continuous Distributions.
                                                              (line 181)
* INDEX:                                 String Functions.    (line  13)
* INDEX <1>:                             String Functions.    (line  20)
* INV:                                   Matrix Algebra Functions.
                                                              (line  58)
* KRONEKER:                              Matrix Algebra Functions.
                                                              (line  65)
* LAG:                                   Miscellaneous Functions.
                                                              (line   6)
* LENGTH:                                String Functions.    (line  30)
* LG10:                                  Mathematics.         (line  12)
* LG10 <1>:                              Matrix Elementwise Functions.
                                                              (line  40)
* LN:                                    Mathematics.         (line  16)
* LN <1>:                                Matrix Elementwise Functions.
                                                              (line  41)
* LNGAMMA:                               Mathematics.         (line  20)
* LOWER:                                 String Functions.    (line  33)
* LPAD:                                  String Functions.    (line  38)
* LTRIM:                                 String Functions.    (line  51)
* MAGIC:                                 Matrix Construction Functions.
                                                              (line  42)
* MAKE:                                  Matrix Construction Functions.
                                                              (line  52)
* MAX:                                   Statistical Functions.
                                                              (line  29)
* MDIAG:                                 Matrix Construction Functions.
                                                              (line  59)
* MEAN:                                  Statistical Functions.
                                                              (line  33)
* MEDIAN:                                Statistical Functions.
                                                              (line  36)
* MIN:                                   Statistical Functions.
                                                              (line  41)
* MISSING:                               Missing Value Functions.
                                                              (line  12)
* MMAX:                                  Matrix Minimum and Maximum and Sum Functions.
                                                              (line  20)
* MMIN:                                  Matrix Minimum and Maximum and Sum Functions.
                                                              (line  19)
* MOD:                                   Miscellaneous Mathematics.
                                                              (line  12)
* MOD <1>:                               Matrix Elementwise Functions.
                                                              (line  51)
* MOD10:                                 Miscellaneous Mathematics.
                                                              (line  18)
* MSSQ:                                  Matrix Minimum and Maximum and Sum Functions.
                                                              (line  22)
* MSUM:                                  Matrix Minimum and Maximum and Sum Functions.
                                                              (line  21)
* NCDF.BETA:                             Continuous Distributions.
                                                              (line  13)
* NCDF.CHISQ:                            Continuous Distributions.
                                                              (line  35)
* NCOL:                                  Matrix Property Functions.
                                                              (line   7)
* NMISS:                                 Missing Value Functions.
                                                              (line  18)
* NORMAL:                                Continuous Distributions.
                                                              (line 119)
* NPDF.BETA:                             Continuous Distributions.
                                                              (line  12)
* NROW:                                  Matrix Property Functions.
                                                              (line   6)
* NUMBER:                                String Functions.    (line  59)
* NVALID:                                Missing Value Functions.
                                                              (line  23)
* PDF.BERNOULLI:                         Discrete Distributions.
                                                              (line   8)
* PDF.BETA:                              Continuous Distributions.
                                                              (line   8)
* PDF.BINOM:                             Discrete Distributions.
                                                              (line  14)
* PDF.BVNOR:                             Continuous Distributions.
                                                              (line  18)
* PDF.CAUCHY:                            Continuous Distributions.
                                                              (line  24)
* PDF.EXP:                               Continuous Distributions.
                                                              (line  40)
* PDF.F:                                 Continuous Distributions.
                                                              (line  54)
* PDF.GAMMA:                             Continuous Distributions.
                                                              (line  64)
* PDF.GEOM:                              Discrete Distributions.
                                                              (line  20)
* PDF.HYPER:                             Discrete Distributions.
                                                              (line  26)
* PDF.LANDAU:                            Continuous Distributions.
                                                              (line  71)
* PDF.LAPLACE:                           Continuous Distributions.
                                                              (line  75)
* PDF.LNORMAL:                           Continuous Distributions.
                                                              (line  98)
* PDF.LOG:                               Discrete Distributions.
                                                              (line  33)
* PDF.LOGISTIC:                          Continuous Distributions.
                                                              (line  91)
* PDF.NEGBIN:                            Discrete Distributions.
                                                              (line  38)
* PDF.NORMAL:                            Continuous Distributions.
                                                              (line 105)
* PDF.NTAIL:                             Continuous Distributions.
                                                              (line 122)
* PDF.PARETO:                            Continuous Distributions.
                                                              (line 128)
* PDF.POISSON:                           Discrete Distributions.
                                                              (line  45)
* PDF.RAYLEIGH:                          Continuous Distributions.
                                                              (line 135)
* PDF.RTAIL:                             Continuous Distributions.
                                                              (line 142)
* PDF.T:                                 Continuous Distributions.
                                                              (line 148)
* PDF.T1G:                               Continuous Distributions.
                                                              (line 156)
* PDF.T2G:                               Continuous Distributions.
                                                              (line 162)
* PDF.UNIFORM:                           Continuous Distributions.
                                                              (line 168)
* PDF.WEIBULL:                           Continuous Distributions.
                                                              (line 179)
* PDF.XPOWER:                            Continuous Distributions.
                                                              (line  48)
* PROBIT:                                Continuous Distributions.
                                                              (line 116)
* RANGE:                                 Set Membership.      (line  20)
* RANK:                                  Matrix Algebra Functions.
                                                              (line  79)
* REPLACE:                               String Functions.    (line  68)
* RESHAPE:                               Matrix Construction Functions.
                                                              (line  73)
* RINDEX:                                String Functions.    (line  14)
* RINDEX <1>:                            String Functions.    (line  21)
* RMAX:                                  Matrix Minimum and Maximum and Sum Functions.
                                                              (line  32)
* RMIN:                                  Matrix Minimum and Maximum and Sum Functions.
                                                              (line  31)
* RND:                                   Miscellaneous Mathematics.
                                                              (line  22)
* RND <1>:                               Matrix Elementwise Functions.
                                                              (line  63)
* RNKORDER:                              Matrix Rank Ordering Functions.
                                                              (line  22)
* RPAD:                                  String Functions.    (line  39)
* RSSQ:                                  Matrix Minimum and Maximum and Sum Functions.
                                                              (line  34)
* RSUM:                                  Matrix Minimum and Maximum and Sum Functions.
                                                              (line  33)
* RTRIM:                                 String Functions.    (line  52)
* RV.BERNOULLI:                          Discrete Distributions.
                                                              (line  10)
* RV.BETA:                               Continuous Distributions.
                                                              (line  11)
* RV.BINOM:                              Discrete Distributions.
                                                              (line  16)
* RV.CAUCHY:                             Continuous Distributions.
                                                              (line  27)
* RV.CHISQ:                              Continuous Distributions.
                                                              (line  34)
* RV.EXP:                                Continuous Distributions.
                                                              (line  43)
* RV.F:                                  Continuous Distributions.
                                                              (line  58)
* RV.GAMMA:                              Continuous Distributions.
                                                              (line  67)
* RV.GEOM:                               Discrete Distributions.
                                                              (line  22)
* RV.HYPER:                              Discrete Distributions.
                                                              (line  28)
* RV.LANDAU:                             Continuous Distributions.
                                                              (line  72)
* RV.LAPLACE:                            Continuous Distributions.
                                                              (line  78)
* RV.LEVY:                               Continuous Distributions.
                                                              (line  82)
* RV.LNORMAL:                            Continuous Distributions.
                                                              (line 101)
* RV.LOG:                                Discrete Distributions.
                                                              (line  34)
* RV.LOGISTIC:                           Continuous Distributions.
                                                              (line  94)
* RV.LVSKEW:                             Continuous Distributions.
                                                              (line  86)
* RV.NEGBIN:                             Discrete Distributions.
                                                              (line  40)
* RV.NORMAL:                             Continuous Distributions.
                                                              (line 108)
* RV.NTAIL:                              Continuous Distributions.
                                                              (line 123)
* RV.PARETO:                             Continuous Distributions.
                                                              (line 131)
* RV.POISSON:                            Discrete Distributions.
                                                              (line  47)
* RV.RAYLEIGH:                           Continuous Distributions.
                                                              (line 138)
* RV.RTAIL:                              Continuous Distributions.
                                                              (line 143)
* RV.T:                                  Continuous Distributions.
                                                              (line 151)
* RV.UNIFORM:                            Continuous Distributions.
                                                              (line 171)
* RV.WEIBULL:                            Continuous Distributions.
                                                              (line 182)
* RV.XPOWER:                             Continuous Distributions.
                                                              (line  49)
* SD:                                    Statistical Functions.
                                                              (line  45)
* SIG.CHISQ:                             Continuous Distributions.
                                                              (line  32)
* SIG.F:                                 Continuous Distributions.
                                                              (line  56)
* SIN:                                   Trigonometry.        (line  27)
* SIN <1>:                               Matrix Elementwise Functions.
                                                              (line  28)
* SOLVE:                                 Matrix Algebra Functions.
                                                              (line  90)
* SQRT:                                  Mathematics.         (line  24)
* SQRT <1>:                              Matrix Elementwise Functions.
                                                              (line  79)
* SSCP:                                  Matrix Minimum and Maximum and Sum Functions.
                                                              (line  44)
* STRING:                                String Functions.    (line  74)
* STRUNC:                                String Functions.    (line  79)
* SUBSTR:                                String Functions.    (line  85)
* SUBSTR <1>:                            String Functions.    (line  90)
* SUM:                                   Statistical Functions.
                                                              (line  48)
* SVAL:                                  Matrix Algebra Functions.
                                                              (line 108)
* SWEEP:                                 Matrix Algebra Functions.
                                                              (line 120)
* SYSMIS:                                Missing Value Functions.
                                                              (line  28)
* T:                                     Matrix Construction Functions.
                                                              (line  93)
* TAN:                                   Trigonometry.        (line  30)
* TIME.DAYS:                             Time Construction.   (line   9)
* TIME.HMS:                              Time Construction.   (line  12)
* TRACE:                                 Matrix Minimum and Maximum and Sum Functions.
                                                              (line  49)
* TRANSPOS:                              Matrix Construction Functions.
                                                              (line  94)
* TRUNC:                                 Miscellaneous Mathematics.
                                                              (line  30)
* TRUNC <1>:                             Matrix Elementwise Functions.
                                                              (line  64)
* UNIFORM:                               Continuous Distributions.
                                                              (line 176)
* UNIFORM <1>:                           Matrix Construction Functions.
                                                              (line 100)
* UPCASE:                                String Functions.    (line 100)
* VALUE:                                 Missing Value Functions.
                                                              (line  31)
* VALUE <1>:                             Missing Value Functions.
                                                              (line  32)
* VARIANCE:                              Statistical Functions.
                                                              (line  51)
* XDATE.DATE:                            Date Extraction.     (line  18)
* XDATE.HOUR:                            Date Extraction.     (line  24)
* XDATE.JDAY:                            Date Extraction.     (line  30)
* XDATE.MDAY:                            Date Extraction.     (line  34)
* XDATE.MINUTE:                          Date Extraction.     (line  38)
* XDATE.MONTH:                           Date Extraction.     (line  42)
* XDATE.QUARTER:                         Date Extraction.     (line  46)
* XDATE.SECOND:                          Date Extraction.     (line  50)
* XDATE.TDAY:                            Date Extraction.     (line  54)
* XDATE.TIME:                            Date Extraction.     (line  57)
* XDATE.WEEK:                            Date Extraction.     (line  62)
* XDATE.WKDAY:                           Date Extraction.     (line  66)
* XDATE.YEAR:                            Date Extraction.     (line  70)
* YRMODA:                                Miscellaneous Functions.
                                                              (line  28)


File: pspp.info,  Node: Command Index,  Next: Concept Index,  Prev: Function Index,  Up: Top

24 Command Index
****************

 [index ]
* Menu:

* *:                                     COMMENT.              (line  6)
* ADD DOCUMENT:                          ADD DOCUMENT.         (line  6)
* ADD FILES:                             ADD FILES.            (line  6)
* ADD VALUE LABELS:                      ADD VALUE LABELS.     (line  6)
* AGGREGATE:                             AGGREGATE.            (line  6)
* APPLY DICTIONARY:                      APPLY DICTIONARY.     (line  6)
* AUTORECODE:                            AUTORECODE.           (line  6)
* BEGIN DATA:                            BEGIN DATA.           (line  6)
* BINOMIAL:                              BINOMIAL.             (line  6)
* BREAK:                                 BREAK.                (line  6)
* CACHE:                                 CACHE.                (line  6)
* CD:                                    CD.                   (line  6)
* CHISQUARE:                             CHISQUARE.            (line  6)
* Cochran:                               COCHRAN.              (line  6)
* COMMENT:                               COMMENT.              (line  6)
* COMPUTE:                               COMPUTE.              (line  6)
* CORRELATIONS:                          CORRELATIONS.         (line  6)
* COUNT:                                 COUNT.                (line  6)
* CROSSTABS:                             CROSSTABS.            (line  6)
* CTABLES:                               CTABLES.              (line  6)
* DATA LIST:                             DATA LIST.            (line  6)
* DATA LIST FIXED:                       DATA LIST FIXED.      (line  6)
* DATA LIST FREE:                        DATA LIST FREE.       (line  6)
* DATA LIST LIST:                        DATA LIST LIST.       (line  6)
* DATAFILE ATTRIBUTE:                    DATAFILE ATTRIBUTE.   (line  6)
* DATASET:                               DATASET.              (line  6)
* DATASET ACTIVATE:                      DATASET.              (line 22)
* DATASET CLOSE:                         DATASET.              (line 41)
* DATASET COPY:                          DATASET.              (line 28)
* DATASET DECLARE:                       DATASET.              (line 35)
* DATASET DISPLAY:                       DATASET.              (line 47)
* DATASET NAME:                          DATASET.              (line 18)
* DEFINE:                                DEFINE.               (line  6)
* DELETE VARIABLES:                      DELETE VARIABLES.     (line  6)
* DESCRIPTIVES:                          DESCRIPTIVES.         (line  6)
* DISPLAY:                               DISPLAY.              (line  6)
* DISPLAY DOCUMENTS:                     DISPLAY DOCUMENTS.    (line  6)
* DISPLAY FILE LABEL:                    DISPLAY FILE LABEL.   (line  6)
* DO IF:                                 DO IF.                (line  6)
* DO REPEAT:                             DO REPEAT.            (line  6)
* DOCUMENT:                              DOCUMENT.             (line  6)
* DROP DOCUMENTS:                        DROP DOCUMENTS.       (line  6)
* ECHO:                                  ECHO.                 (line  6)
* END CASE:                              END CASE.             (line  6)
* END DATA:                              BEGIN DATA.           (line  6)
* END FILE:                              END FILE.             (line  6)
* END MATRIX:                            MATRIX.               (line  6)
* ERASE:                                 ERASE.                (line  6)
* EXAMINE:                               EXAMINE.              (line  6)
* EXECUTE:                               EXECUTE.              (line  6)
* EXPORT:                                EXPORT.               (line  6)
* FACTOR:                                FACTOR.               (line  6)
* FILE HANDLE:                           FILE HANDLE.          (line  6)
* FILE LABEL:                            FILE LABEL.           (line  6)
* FILTER:                                FILTER.               (line  6)
* FINISH:                                FINISH.               (line  6)
* FLIP:                                  FLIP.                 (line  6)
* FORMATS:                               FORMATS.              (line  6)
* FREQUENCIES:                           FREQUENCIES.          (line  6)
* FRIEDMAN:                              FRIEDMAN.             (line  6)
* GET:                                   Reading data from a pre-prepared PSPP file.
                                                               (line  6)
* GET <1>:                               GET.                  (line  6)
* GET DATA:                              GET DATA.             (line  6)
* GLM:                                   GLM.                  (line  6)
* GRAPH:                                 GRAPH.                (line  6)
* HOST:                                  HOST.                 (line  6)
* IF:                                    IF.                   (line  6)
* IMPORT:                                IMPORT.               (line  6)
* INCLUDE:                               INCLUDE.              (line  6)
* INPUT PROGRAM:                         INPUT PROGRAM.        (line  6)
* INSERT:                                INSERT.               (line  6)
* K-S:                                   KOLMOGOROV-SMIRNOV.   (line  6)
* K-W:                                   KRUSKAL-WALLIS.       (line  6)
* KENDALL:                               KENDALL.              (line  6)
* KOLMOGOROV-SMIRNOV:                    KOLMOGOROV-SMIRNOV.   (line  6)
* KRUSKAL-WALLIS:                        KRUSKAL-WALLIS.       (line  6)
* LEAVE:                                 LEAVE.                (line  6)
* LIST:                                  Listing the data.     (line  6)
* LIST <1>:                              LIST.                 (line  6)
* LOGISTIC REGRESSION:                   LOGISTIC REGRESSION.  (line  6)
* LOOP:                                  LOOP.                 (line  6)
* M-W:                                   MANN-WHITNEY.         (line  6)
* MANN-WHITNEY:                          MANN-WHITNEY.         (line  6)
* MATCH FILES:                           MATCH FILES.          (line  6)
* MATRIX:                                MATRIX.               (line  6)
* MATRIX DATA:                           MATRIX DATA.          (line  6)
* Matrix file:                           Matrix Files.         (line  6)
* MCNEMAR:                               MCNEMAR.              (line  6)
* MCONVERT:                              MCONVERT.             (line  6)
* MEANS:                                 MEANS.                (line  6)
* MEDIAN:                                MEDIAN.               (line  6)
* MISSING VALUES:                        MISSING VALUES.       (line  6)
* MRSETS:                                MRSETS.               (line  6)
* N OF CASES:                            N OF CASES.           (line  6)
* NEW FILE:                              NEW FILE.             (line  6)
* NPAR TESTS:                            NPAR TESTS.           (line  6)
* NUMERIC:                               NUMERIC.              (line  6)
* ONEWAY:                                ONEWAY.               (line  6)
* OUTPUT:                                OUTPUT.               (line  6)
* PERMISSIONS:                           PERMISSIONS.          (line  6)
* PRESERVE:                              PRESERVE and RESTORE. (line  6)
* PRINT:                                 PRINT.                (line  6)
* PRINT EJECT:                           PRINT EJECT.          (line  6)
* PRINT FORMATS:                         PRINT FORMATS.        (line  6)
* PRINT SPACE:                           PRINT SPACE.          (line  6)
* QUICK CLUSTER:                         QUICK CLUSTER.        (line  6)
* RANK:                                  RANK.                 (line  6)
* RECODE:                                RECODE.               (line  6)
* REGRESSION:                            Linear Regression.    (line  6)
* REGRESSION <1>:                        Syntax.               (line  6)
* RELIABILITY:                           RELIABILITY.          (line  6)
* RENAME VARIABLES:                      RENAME VARIABLES.     (line  6)
* REREAD:                                REREAD.               (line  6)
* RESTORE:                               PRESERVE and RESTORE. (line  6)
* ROC:                                   ROC.                  (line  6)
* RUNS:                                  RUNS.                 (line  6)
* SAMPLE:                                SAMPLE.               (line  6)
* SAVE:                                  Saving data to a PSPP file..
                                                               (line  6)
* SAVE <1>:                              SAVE.                 (line  6)
* SAVE DATA COLLECTION:                  SAVE DATA COLLECTION. (line  6)
* SAVE TRANSLATE:                        SAVE TRANSLATE.       (line  6)
* SELECT IF:                             SELECT IF.            (line  6)
* SET:                                   SET.                  (line  6)
* SHOW:                                  SHOW.                 (line  6)
* SIGN:                                  SIGN.                 (line  6)
* SORT CASES:                            SORT CASES.           (line  6)
* SORT VARIABLES:                        SORT VARIABLES.       (line  6)
* SPLIT FILE:                            SPLIT FILE.           (line  6)
* STRING:                                STRING.               (line  6)
* SUBTITLE:                              SUBTITLE.             (line  6)
* SYSFILE INFO:                          SYSFILE INFO.         (line  6)
* T-TEST:                                Testing for differences of means.
                                                               (line  6)
* T-TEST <1>:                            T-TEST.               (line  6)
* TEMPORARY:                             TEMPORARY.            (line  6)
* TITLE:                                 TITLE.                (line  6)
* UPDATE:                                UPDATE.               (line  6)
* VALUE LABELS:                          VALUE LABELS.         (line  6)
* VARIABLE ALIGNMENT:                    VARIABLE ALIGNMENT.   (line  6)
* VARIABLE ATTRIBUTE:                    VARIABLE ATTRIBUTE.   (line  6)
* VARIABLE LABELS:                       VARIABLE LABELS.      (line  6)
* VARIABLE LEVEL:                        VARIABLE LEVEL.       (line  6)
* VARIABLE ROLE:                         VARIABLE ROLE.        (line  6)
* VARIABLE WIDTH:                        VARIABLE WIDTH.       (line  6)
* VECTOR:                                VECTOR.               (line  6)
* WEIGHT:                                WEIGHT.               (line  6)
* WILCOXON:                              WILCOXON.             (line  6)
* WRITE:                                 WRITE.                (line  6)
* WRITE FORMATS:                         WRITE FORMATS.        (line  6)
* XEXPORT:                               XEXPORT.              (line  6)
* XSAVE:                                 XSAVE.                (line  6)


File: pspp.info,  Node: Concept Index,  Next: GNU Free Documentation License,  Prev: Command Index,  Up: Top

25 Concept Index
****************

 [index ]
* Menu:

* ":                                     Tokens.              (line  64)
* “is defined as”:                       BNF.                 (line  44)
* $CASENUM:                              System Variables.    (line  11)
* $DATE:                                 System Variables.    (line  15)
* $DATE11:                               System Variables.    (line  19)
* $JDATE:                                System Variables.    (line  23)
* $LENGTH:                               System Variables.    (line  27)
* $SYSMIS:                               System Variables.    (line  30)
* $TIME:                                 System Variables.    (line  33)
* $WIDTH:                                System Variables.    (line  37)
* &:                                     Logical Operators.   (line  11)
* ':                                     Tokens.              (line  64)
* (:                                     Functions.           (line   6)
* ( ):                                   Grouping Operators.  (line   6)
* ):                                     Functions.           (line   6)
* *:                                     Arithmetic Operators.
                                                              (line  15)
* **:                                    Arithmetic Operators.
                                                              (line  24)
* +:                                     Arithmetic Operators.
                                                              (line   9)
* -:                                     Arithmetic Operators.
                                                              (line  12)
* - <1>:                                 Arithmetic Operators.
                                                              (line  29)
* .:                                     Attributes.          (line  15)
* . <1>:                                 BNF.                 (line  29)
* /:                                     Arithmetic Operators.
                                                              (line  19)
* <:                                     Relational Operators.
                                                              (line  25)
* <=:                                    Relational Operators.
                                                              (line  21)
* <>:                                    Relational Operators.
                                                              (line  37)
* =:                                     Relational Operators.
                                                              (line  17)
* >:                                     Relational Operators.
                                                              (line  33)
* >=:                                    Relational Operators.
                                                              (line  29)
* _:                                     Attributes.          (line  20)
* |:                                     Logical Operators.   (line  17)
* ~:                                     Logical Operators.   (line  23)
* ~=:                                    Relational Operators.
                                                              (line  37)
* absolute value:                        Miscellaneous Mathematics.
                                                              (line   9)
* addition:                              Arithmetic Operators.
                                                              (line   9)
* analysis of variance:                  GLM.                 (line   6)
* analysis of variance <1>:              ONEWAY.              (line   6)
* AND:                                   Logical Operators.   (line  11)
* ANOVA:                                 GLM.                 (line   6)
* ANOVA <1>:                             ONEWAY.              (line   6)
* arccosine:                             Trigonometry.        (line   9)
* arcsine:                               Trigonometry.        (line  15)
* arctangent:                            Trigonometry.        (line  20)
* Area under curve:                      ROC.                 (line   6)
* arguments, invalid:                    Date Construction.   (line  35)
* arguments, minimum valid:              Statistical Functions.
                                                              (line  15)
* arguments, of date construction functions: Date Construction.
                                                              (line   6)
* arguments, of date extraction functions: Date Extraction.   (line   6)
* arithmetic mean:                       MEANS.               (line  42)
* arithmetic operators:                  Arithmetic Operators.
                                                              (line   6)
* attributes of variables:               Attributes.          (line   6)
* Backus-Naur Form:                      BNF.                 (line   6)
* bar chart:                             FREQUENCIES.         (line  89)
* bar chart <1>:                         BAR CHART.           (line   6)
* bar chart <2>:                         CROSSTABS.           (line 142)
* Batch syntax:                          Syntax Variants.     (line   6)
* binary formats:                        Binary and Hexadecimal Numeric Formats.
                                                              (line   6)
* binomial test:                         BINOMIAL.            (line   6)
* bivariate logistic regression:         LOGISTIC REGRESSION. (line   6)
* BNF:                                   BNF.                 (line   6)
* Boolean:                               Boolean Values.      (line   6)
* Boolean <1>:                           Logical Operators.   (line   6)
* boxplot:                               EXAMINE.             (line  57)
* bugs:                                  Bugs.                (line   6)
* case conversion:                       String Functions.    (line 100)
* case-sensitivity:                      Tokens.              (line  20)
* case-sensitivity <1>:                  Tokens.              (line  64)
* cases:                                 Data Input and Output.
                                                              (line   6)
* changing directory:                    CD.                  (line   6)
* changing file permissions:             PERMISSIONS.         (line   6)
* chi-square:                            CROSSTABS.           (line 103)
* chi-square test:                       CHISQUARE.           (line   6)
* chi-square test of independence:       CROSSTABS.           (line 161)
* clustering:                            QUICK CLUSTER.       (line   6)
* Cochran Q test:                        COCHRAN.             (line   6)
* coefficient of concordance:            KENDALL.             (line   6)
* coefficient of variation:              Statistical Functions.
                                                              (line  24)
* comma separated values:                Reading data from other sources.
                                                              (line   6)
* command file:                          Files.               (line  10)
* command syntax, description of:        BNF.                 (line   6)
* commands, ordering:                    Order of Commands.   (line   6)
* commands, structure:                   Commands.            (line   6)
* commands, unimplemented:               Not Implemented.     (line   9)
* concatenation:                         String Functions.    (line   8)
* conditionals:                          Conditionals and Looping.
                                                              (line   6)
* consistency:                           Testing data consistency.
                                                              (line   6)
* constructing dates:                    Date Construction.   (line   6)
* constructing times:                    Time Construction.   (line   6)
* control flow:                          Conditionals and Looping.
                                                              (line   6)
* convention, TO:                        Sets of Variables.   (line   6)
* copyright:                             License.             (line   6)
* correlation:                           CORRELATIONS.        (line  20)
* cosine:                                Trigonometry.        (line  24)
* covariance:                            CORRELATIONS.        (line  52)
* Cronbach’s Alpha:                      RELIABILITY.         (line  13)
* cross-case function:                   Miscellaneous Functions.
                                                              (line   6)
* currency formats:                      Custom Currency Formats.
                                                              (line   6)
* custom attributes:                     Attributes.          (line 129)
* custom tables:                         CTABLES.             (line   6)
* data:                                  Data Input and Output.
                                                              (line   6)
* data file:                             Files.               (line  17)
* data files:                            GET DATA /TYPE=TXT.  (line  14)
* data reduction:                        FACTOR.              (line   6)
* Data, embedding in syntax files:       BEGIN DATA.          (line   6)
* data, embedding in syntax files:       DATA LIST.           (line   6)
* data, fixed-format, reading:           DATA LIST FIXED.     (line   6)
* data, reading from a file:             DATA LIST.           (line   6)
* databases:                             Reading data from other sources.
                                                              (line   6)
* databases <1>:                         GET DATA /TYPE=PSQL. (line  13)
* dataset:                               Datasets.            (line   6)
* date examination:                      Date Extraction.     (line   6)
* date formats:                          Time and Date Formats.
                                                              (line   6)
* date, Julian:                          Miscellaneous Functions.
                                                              (line  28)
* dates:                                 Time and Date.       (line   6)
* dates, concepts:                       Time and Date Concepts.
                                                              (line  15)
* dates, constructing:                   Date Construction.   (line   6)
* dates, day of the month:               Date Extraction.     (line  34)
* dates, day of the week:                Date Extraction.     (line  66)
* dates, day of the year:                Date Extraction.     (line  30)
* dates, day-month-year:                 Date Construction.   (line  39)
* dates, in days:                        Date Extraction.     (line  18)
* dates, in hours:                       Date Extraction.     (line  24)
* dates, in minutes:                     Date Extraction.     (line  38)
* dates, in months:                      Date Extraction.     (line  42)
* dates, in quarters:                    Date Extraction.     (line  46)
* dates, in seconds:                     Date Extraction.     (line  50)
* dates, in weekdays:                    Date Extraction.     (line  66)
* dates, in weeks:                       Date Extraction.     (line  62)
* dates, in years:                       Date Extraction.     (line  70)
* dates, mathematical properties of:     Time and Date Arithmetic.
                                                              (line   6)
* dates, month-year:                     Date Construction.   (line  44)
* dates, quarter-year:                   Date Construction.   (line  48)
* dates, time of day:                    Date Extraction.     (line  57)
* dates, valid:                          Time and Date.       (line   6)
* dates, week-year:                      Date Construction.   (line  52)
* dates, year-day:                       Date Construction.   (line  56)
* day of the month:                      Date Extraction.     (line  34)
* day of the week:                       Date Extraction.     (line  66)
* day of the year:                       Date Extraction.     (line  30)
* day-month-year:                        Date Construction.   (line  39)
* days:                                  Time Construction.   (line   9)
* days <1>:                              Time Extraction.     (line   9)
* days <2>:                              Date Extraction.     (line  18)
* days <3>:                              Date Extraction.     (line  54)
* decimal places:                        OUTPUT.              (line   6)
* description of command syntax:         BNF.                 (line   6)
* deviation, standard:                   Statistical Functions.
                                                              (line  45)
* dictionary:                            Datasets.            (line   6)
* directory:                             CD.                  (line   6)
* division:                              Arithmetic Operators.
                                                              (line  19)
* DocBook:                               Introduction.        (line  15)
* Embedding data in syntax files:        BEGIN DATA.          (line   6)
* embedding data in syntax files:        DATA LIST.           (line   6)
* embedding fixed-format data:           DATA LIST FIXED.     (line   6)
* encoding, characters:                  SET.                 (line 434)
* EQ:                                    Relational Operators.
                                                              (line  17)
* equality, testing:                     Relational Operators.
                                                              (line  17)
* erroneous data:                        Identifying incorrect data.
                                                              (line   6)
* errors, in data:                       Identifying incorrect data.
                                                              (line   6)
* examination, of times:                 Time Extraction.     (line   6)
* Exploratory data analysis:             EXAMINE.             (line   6)
* Exploratory data analysis <1>:         GRAPH.               (line   6)
* exponentiation:                        Arithmetic Operators.
                                                              (line  24)
* expression:                            BNF.                 (line  41)
* expressions, mathematical:             Expressions.         (line   6)
* extraction, of dates:                  Date Extraction.     (line   6)
* extraction, of time:                   Time Extraction.     (line   6)
* factor analysis:                       FACTOR.              (line   6)
* factorial anova:                       GLM.                 (line   6)
* false:                                 Logical Operators.   (line   6)
* file definition commands:              Types of Commands.   (line  14)
* file handles:                          File Handles.        (line   6)
* file mode:                             PERMISSIONS.         (line   6)
* file, command:                         Files.               (line  10)
* file, data:                            Files.               (line  17)
* file, output:                          Files.               (line  21)
* file, portable:                        Files.               (line  31)
* file, syntax file:                     Files.               (line  10)
* file, system:                          Files.               (line  27)
* fixed effects:                         GLM.                 (line   6)
* fixed-format data, reading:            DATA LIST FIXED.     (line   6)
* flow of control:                       Conditionals and Looping.
                                                              (line   6)
* formats:                               Input and Output Formats.
                                                              (line   6)
* Friedman test:                         FRIEDMAN.            (line   6)
* function, cross-case:                  Miscellaneous Functions.
                                                              (line   6)
* functions:                             Functions.           (line   6)
* functions, miscellaneous:              Miscellaneous Functions.
                                                              (line   6)
* functions, missing-value:              Missing Value Functions.
                                                              (line   6)
* functions, statistical:                Statistical Functions.
                                                              (line   6)
* functions, string:                     String Functions.    (line   6)
* functions, time & date:                Time and Date.       (line   6)
* GE:                                    Relational Operators.
                                                              (line  29)
* geometric mean:                        MEANS.               (line  58)
* Gnumeric:                              GET DATA /TYPE=GNM/ODS.
                                                              (line  13)
* Graphic user interface:                Invoking PSPPIRE.    (line   9)
* greater than:                          Relational Operators.
                                                              (line  33)
* greater than or equal to:              Relational Operators.
                                                              (line  29)
* grouping operators:                    Grouping Operators.  (line   6)
* GT:                                    Relational Operators.
                                                              (line  33)
* harmonic mean:                         MEANS.               (line  57)
* headers:                               SET.                 (line 394)
* hexadecimal formats:                   Binary and Hexadecimal Numeric Formats.
                                                              (line   6)
* histogram:                             FREQUENCIES.         (line  71)
* histogram <1>:                         EXAMINE.             (line  57)
* histogram <2>:                         HISTOGRAM.           (line   6)
* hours:                                 Time Extraction.     (line  12)
* hours <1>:                             Date Extraction.     (line  24)
* hours-minutes-seconds:                 Time Construction.   (line  12)
* HTML:                                  Introduction.        (line  15)
* HTML <1>:                              HTML Output Options. (line   6)
* Hypothesis testing:                    Hypothesis Testing.  (line   6)
* identifiers:                           Tokens.              (line  11)
* identifiers, reserved:                 Tokens.              (line  25)
* inequality, testing:                   Relational Operators.
                                                              (line  37)
* input:                                 Data Input and Output.
                                                              (line   6)
* input program commands:                Types of Commands.   (line  21)
* integer:                               BNF.                 (line  17)
* integers:                              Tokens.              (line  44)
* Interactive syntax:                    Syntax Variants.     (line   6)
* intersection, logical:                 Logical Operators.   (line  11)
* introduction:                          Introduction.        (line   6)
* inverse cosine:                        Trigonometry.        (line   9)
* inverse sine:                          Trigonometry.        (line  15)
* inverse tangent:                       Trigonometry.        (line  20)
* inversion, logical:                    Logical Operators.   (line  23)
* Inverting data:                        Inverting negatively coded variables.
                                                              (line   6)
* invocation:                            Invoking PSPP.       (line   6)
* Invocation:                            Invoking pspp-convert.
                                                              (line   6)
* Invocation <1>:                        Invoking pspp-output.
                                                              (line   6)
* Invocation <2>:                        Invoking pspp-dump-sav.
                                                              (line   6)
* Julian date:                           Miscellaneous Functions.
                                                              (line  28)
* K-means clustering:                    QUICK CLUSTER.       (line   6)
* Kendall’s W test:                      KENDALL.             (line   6)
* keywords:                              BNF.                 (line  10)
* Kolmogorov-Smirnov test:               KOLMOGOROV-SMIRNOV.  (line   6)
* Kruskal-Wallis test:                   KRUSKAL-WALLIS.      (line   6)
* labels, value:                         Attributes.          (line  59)
* labels, variable:                      Attributes.          (line  56)
* language, command structure:           Commands.            (line   6)
* language, lexical analysis:            Tokens.              (line   6)
* language, PSPP:                        Introduction.        (line   6)
* language, PSPP <1>:                    Language.            (line   6)
* language, tokens:                      Tokens.              (line   6)
* LE:                                    Relational Operators.
                                                              (line  21)
* length:                                SET.                 (line 394)
* less than:                             Relational Operators.
                                                              (line  25)
* less than or equal to:                 Relational Operators.
                                                              (line  21)
* lexical analysis:                      Tokens.              (line   6)
* licence:                               License.             (line   6)
* license:                               License.             (line   6)
* Likert scale:                          Inverting negatively coded variables.
                                                              (line   6)
* linear regression:                     Linear Regression.   (line   6)
* linear regression <1>:                 REGRESSION.          (line   6)
* locale:                                SET.                 (line 434)
* logarithms:                            Mathematics.         (line  12)
* logical intersection:                  Logical Operators.   (line  11)
* logical inversion:                     Logical Operators.   (line  23)
* logical operators:                     Logical Operators.   (line   6)
* logical union:                         Logical Operators.   (line  17)
* logistic regression:                   LOGISTIC REGRESSION. (line   6)
* loops:                                 Conditionals and Looping.
                                                              (line   6)
* LT:                                    Relational Operators.
                                                              (line  25)
* macro:                                 DEFINE.              (line   5)
* Mann-Whitney U test:                   MANN-WHITNEY.        (line   6)
* mathematical expressions:              Expressions.         (line   6)
* mathematics:                           Functions.           (line   6)
* mathematics, advanced:                 Mathematics.         (line   6)
* mathematics, applied to times & dates: Time and Date Arithmetic.
                                                              (line   6)
* mathematics, miscellaneous:            Miscellaneous Mathematics.
                                                              (line   6)
* maximum:                               Statistical Functions.
                                                              (line  29)
* McNemar test:                          MCNEMAR.             (line   6)
* mean:                                  Statistical Functions.
                                                              (line  33)
* means:                                 MEANS.               (line   6)
* measurement level:                     Attributes.          (line  73)
* median:                                Statistical Functions.
                                                              (line  36)
* Median test:                           MEDIAN.              (line   6)
* membership, of set:                    Set Membership.      (line   6)
* memory, amount used to store cases:    SET.                 (line 234)
* minimum:                               Statistical Functions.
                                                              (line  41)
* minimum valid number of arguments:     Statistical Functions.
                                                              (line  15)
* minutes:                               Time Extraction.     (line  15)
* minutes <1>:                           Date Extraction.     (line  38)
* missing values:                        Missing Observations.
                                                              (line   6)
* missing values <1>:                    Attributes.          (line  46)
* missing values <2>:                    Missing Value Functions.
                                                              (line   6)
* mode:                                  PERMISSIONS.         (line   6)
* modulus:                               Miscellaneous Mathematics.
                                                              (line  12)
* modulus, by 10:                        Miscellaneous Mathematics.
                                                              (line  18)
* month-year:                            Date Construction.   (line  44)
* months:                                Date Extraction.     (line  42)
* multiplication:                        Arithmetic Operators.
                                                              (line  15)
* names, of functions:                   Functions.           (line   6)
* NE:                                    Relational Operators.
                                                              (line  37)
* negation:                              Arithmetic Operators.
                                                              (line  29)
* nonparametric tests:                   NPAR TESTS.          (line   6)
* nonterminals:                          BNF.                 (line  33)
* normality, testing:                    Testing for normality.
                                                              (line   6)
* normality, testing <1>:                EXAMINE.             (line   6)
* normality, testing <2>:                GRAPH.               (line   6)
* NOT:                                   Logical Operators.   (line  23)
* npplot:                                EXAMINE.             (line  57)
* null hypothesis:                       Hypothesis Testing.  (line   6)
* number:                                BNF.                 (line  14)
* numbers:                               Tokens.              (line  44)
* numbers, converting from strings:      String Functions.    (line  59)
* numbers, converting to strings:        String Functions.    (line  74)
* numeric formats:                       Basic Numeric Formats.
                                                              (line   6)
* obligations, your:                     License.             (line   6)
* observations:                          Data Input and Output.
                                                              (line   6)
* OpenDocument:                          GET DATA /TYPE=GNM/ODS.
                                                              (line  13)
* operations, order of:                  Order of Operations. (line   6)
* operator precedence:                   Order of Operations. (line   6)
* operators:                             Tokens.              (line  95)
* operators <1>:                         BNF.                 (line  26)
* operators <2>:                         Functions.           (line   6)
* operators, arithmetic:                 Arithmetic Operators.
                                                              (line   6)
* operators, grouping:                   Grouping Operators.  (line   6)
* operators, logical:                    Logical Operators.   (line   6)
* OR:                                    Logical Operators.   (line  17)
* order of commands:                     Order of Commands.   (line   6)
* order of operations:                   Order of Operations. (line   6)
* output:                                Data Input and Output.
                                                              (line   6)
* output file:                           Files.               (line  21)
* p-value:                               Hypothesis Testing.  (line   6)
* pager:                                 SET.                 (line 394)
* parentheses:                           Grouping Operators.  (line   6)
* parentheses <1>:                       Functions.           (line   6)
* PDF:                                   Introduction.        (line  15)
* PDF <1>:                               PDF PostScript SVG and PNG Output Options.
                                                              (line   6)
* percentiles:                           FREQUENCIES.         (line  64)
* percentiles <1>:                       EXAMINE.             (line  96)
* period:                                Attributes.          (line  15)
* piechart:                              FREQUENCIES.         (line  79)
* PNG:                                   PDF PostScript SVG and PNG Output Options.
                                                              (line   6)
* portable file:                         Files.               (line  31)
* postgres:                              GET DATA /TYPE=PSQL. (line  13)
* PostScript:                            Introduction.        (line  15)
* Postscript:                            PDF PostScript SVG and PNG Output Options.
                                                              (line   6)
* precedence, operator:                  Order of Operations. (line   6)
* precision, of output:                  OUTPUT.              (line   6)
* principal axis factoring:              FACTOR.              (line   6)
* principal components analysis:         FACTOR.              (line   6)
* print format:                          Attributes.          (line  63)
* procedures:                            Types of Commands.   (line  33)
* productions:                           BNF.                 (line  33)
* productions <1>:                       BNF.                 (line  44)
* PSPP language:                         Introduction.        (line   6)
* PSPP, command structure:               Commands.            (line   6)
* PSPP, invoking:                        Invoking PSPP.       (line   6)
* PSPP, language:                        Language.            (line   6)
* pspp-convert:                          Invoking pspp-convert.
                                                              (line   6)
* pspp-dump-sav:                         Invoking pspp-dump-sav.
                                                              (line   6)
* pspp-output:                           Invoking pspp-output.
                                                              (line   6)
* PSPPIRE:                               Invoking PSPPIRE.    (line   9)
* punctuators:                           Tokens.              (line  95)
* punctuators <1>:                       BNF.                 (line  26)
* Q, Cochran Q:                          COCHRAN.             (line   6)
* quarter-year:                          Date Construction.   (line  48)
* quarters:                              Date Extraction.     (line  46)
* reading data:                          Reading data from a text file.
                                                              (line   6)
* reading data from a file:              DATA LIST.           (line   6)
* reading fixed-format data:             DATA LIST FIXED.     (line   6)
* reals:                                 Tokens.              (line  44)
* Receiver Operating Characteristic:     ROC.                 (line   6)
* recoding data:                         Dealing with suspicious data.
                                                              (line   6)
* regression:                            REGRESSION.          (line   6)
* reliability:                           Testing data consistency.
                                                              (line   6)
* replacing substrings:                  String Functions.    (line  68)
* reserved identifiers:                  Tokens.              (line  25)
* restricted expressions:                Matrix Expressions.  (line  35)
* restricted transformations:            Types of Commands.   (line  29)
* rights, your:                          License.             (line   6)
* rounding:                              Miscellaneous Mathematics.
                                                              (line  22)
* runs test:                             RUNS.                (line   6)
* saving:                                Saving data to a PSPP file..
                                                              (line   6)
* scatterplot:                           SCATTERPLOT.         (line   6)
* scratch variables:                     Scratch Variables.   (line   6)
* screening:                             Data Screening and Transformation.
                                                              (line   6)
* searching strings:                     String Functions.    (line  13)
* seconds:                               Time Extraction.     (line  18)
* seconds <1>:                           Date Extraction.     (line  50)
* set membership:                        Set Membership.      (line   6)
* Shapiro-Wilk:                          EXAMINE.             (line  72)
* sign test:                             SIGN.                (line   6)
* sine:                                  Trigonometry.        (line  27)
* spreadlevel plot:                      EXAMINE.             (line  57)
* spreadsheet files:                     GET DATA /TYPE=GNM/ODS.
                                                              (line  13)
* spreadsheets:                          Reading data from other sources.
                                                              (line   6)
* square roots:                          Mathematics.         (line  24)
* standard deviation:                    Statistical Functions.
                                                              (line  45)
* start symbol:                          BNF.                 (line  58)
* statistics:                            Statistical Functions.
                                                              (line   6)
* string:                                BNF.                 (line  20)
* string formats:                        String Formats.      (line   6)
* string functions:                      String Functions.    (line   6)
* strings:                               Tokens.              (line  64)
* strings, case of:                      String Functions.    (line  33)
* strings, case of <1>:                  String Functions.    (line 100)
* strings, concatenation of:             String Functions.    (line   8)
* strings, converting from numbers:      String Functions.    (line  74)
* strings, converting to numbers:        String Functions.    (line  59)
* strings, finding length of:            String Functions.    (line  30)
* strings, padding:                      String Functions.    (line  38)
* strings, replacing substrings:         String Functions.    (line  68)
* strings, taking substrings of:         String Functions.    (line  85)
* strings, trimming:                     String Functions.    (line  51)
* strings, trimming <1>:                 String Functions.    (line  79)
* strings, truncating:                   String Functions.    (line  79)
* substrings:                            String Functions.    (line  85)
* subtraction:                           Arithmetic Operators.
                                                              (line  12)
* sum:                                   Statistical Functions.
                                                              (line  48)
* SVG:                                   PDF PostScript SVG and PNG Output Options.
                                                              (line   6)
* symbol, start:                         BNF.                 (line  58)
* syntax file:                           Files.               (line  10)
* SYSMIS:                                Dealing with suspicious data.
                                                              (line   6)
* system file:                           Files.               (line  27)
* system files:                          Reading data from a pre-prepared PSPP file.
                                                              (line   6)
* system variables:                      System Variables.    (line   6)
* system-missing:                        Logical Operators.   (line   6)
* T-test:                                Testing for differences of means.
                                                              (line   6)
* tables, custom:                        CTABLES.             (line   6)
* tangent:                               Trigonometry.        (line  30)
* terminals:                             BNF.                 (line  10)
* terminals and nonterminals, differences: BNF.               (line  50)
* testing for equality:                  Relational Operators.
                                                              (line  17)
* testing for inequality:                Relational Operators.
                                                              (line  37)
* TeX:                                   TeX Output Options.  (line   6)
* tex:                                   TeX Output Options.  (line   6)
* text files:                            GET DATA /TYPE=TXT.  (line  14)
* time:                                  Date Extraction.     (line  57)
* time examination:                      Time Extraction.     (line   6)
* time formats:                          Time and Date Formats.
                                                              (line   6)
* time, concepts:                        Time and Date Concepts.
                                                              (line   6)
* time, in days:                         Time Construction.   (line   9)
* time, in days <1>:                     Time Extraction.     (line   9)
* time, in days <2>:                     Date Extraction.     (line  18)
* time, in hours:                        Time Extraction.     (line  12)
* time, in hours <1>:                    Date Extraction.     (line  24)
* time, in hours-minutes-seconds:        Time Construction.   (line  12)
* time, in minutes:                      Time Extraction.     (line  15)
* time, in minutes <1>:                  Date Extraction.     (line  38)
* time, in seconds:                      Time Extraction.     (line  18)
* time, in seconds <1>:                  Date Extraction.     (line  50)
* time, instants of:                     Time and Date Concepts.
                                                              (line  15)
* time, intervals:                       Time and Date Concepts.
                                                              (line   6)
* time, lengths of:                      Time Extraction.     (line   6)
* time, mathematical properties of:      Time and Date Arithmetic.
                                                              (line   6)
* times:                                 Time and Date.       (line   6)
* times, constructing:                   Time Construction.   (line   6)
* times, in days:                        Date Extraction.     (line  54)
* tnumbers:                              SET.                 (line 394)
* TO convention:                         Sets of Variables.   (line   6)
* tokens:                                Tokens.              (line   6)
* transformation:                        Data Screening and Transformation.
                                                              (line   6)
* transformations:                       Types of Commands.   (line  25)
* transformations <1>:                   Data Manipulation.   (line   6)
* trigonometry:                          Trigonometry.        (line   6)
* troubleshooting:                       Bugs.                (line   6)
* true:                                  Logical Operators.   (line   6)
* truncation:                            Miscellaneous Mathematics.
                                                              (line  30)
* type of variables:                     Attributes.          (line  29)
* U, Mann-Whitney U:                     MANN-WHITNEY.        (line   6)
* unimplemented commands:                Not Implemented.     (line   9)
* union, logical:                        Logical Operators.   (line  17)
* univariate analysis of variance:       GLM.                 (line   6)
* utility commands:                      Types of Commands.   (line   9)
* value label:                           Miscellaneous Functions.
                                                              (line  41)
* value labels:                          Attributes.          (line  59)
* values, Boolean:                       Boolean Values.      (line   6)
* values, missing:                       Missing Observations.
                                                              (line   6)
* values, missing <1>:                   Attributes.          (line  46)
* values, missing <2>:                   Missing Value Functions.
                                                              (line   6)
* values, system-missing:                Logical Operators.   (line   6)
* var-list:                              BNF.                 (line  38)
* var-name:                              BNF.                 (line  23)
* variable:                              Datasets.            (line   6)
* variable labels:                       Attributes.          (line  56)
* variable names, ending with period:    Attributes.          (line  15)
* variable role:                         Attributes.          (line 133)
* variables:                             Defining Variables.  (line   6)
* Variables:                             Manipulating Variables.
                                                              (line   6)
* variables, attributes of:              Attributes.          (line   6)
* variables, system:                     System Variables.    (line   6)
* variables, type:                       Attributes.          (line  29)
* variables, width:                      Attributes.          (line  32)
* variance:                              Statistical Functions.
                                                              (line  51)
* variation, coefficient of:             Statistical Functions.
                                                              (line  24)
* week:                                  Date Extraction.     (line  62)
* week-year:                             Date Construction.   (line  52)
* weekday:                               Date Extraction.     (line  66)
* white space, trimming:                 String Functions.    (line  51)
* white space, trimming <1>:             String Functions.    (line  79)
* width:                                 SET.                 (line 394)
* width of variables:                    Attributes.          (line  32)
* wilcoxon matched pairs signed ranks test: WILCOXON.         (line   6)
* workspace:                             SET.                 (line 234)
* write format:                          Attributes.          (line  69)
* year-day:                              Date Construction.   (line  56)
* years:                                 Date Extraction.     (line  70)
* your rights and obligations:           License.             (line   6)


File: pspp.info,  Node: GNU Free Documentation License,  Prev: Concept Index,  Up: Top

Appendix A GNU Free Documentation License
*****************************************

                     Version 1.3, 3 November 2008

     Copyright © 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
     <http://fsf.org/>

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document “free” in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of “copyleft”, which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.  We
     recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it can
     be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     “Document”, below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as “you”.  You accept
     the license if you copy, modify or distribute the work in a way
     requiring permission under copyright law.

     A “Modified Version” of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A “Secondary Section” is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document’s overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The “Invariant Sections” are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in the
     notice that says that the Document is released under this License.
     If a section does not fit the above definition of Secondary then it
     is not allowed to be designated as Invariant.  The Document may
     contain zero Invariant Sections.  If the Document does not identify
     any Invariant Sections then there are none.

     The “Cover Texts” are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A “Transparent” copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images composed
     of pixels) generic paint programs or (for drawings) some widely
     available drawing editor, and that is suitable for input to text
     formatters or for automatic translation to a variety of formats
     suitable for input to text formatters.  A copy made in an otherwise
     Transparent file format whose markup, or absence of markup, has
     been arranged to thwart or discourage subsequent modification by
     readers is not Transparent.  An image format is not Transparent if
     used for any substantial amount of text.  A copy that is not
     “Transparent” is called “Opaque”.

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and standard-conforming
     simple HTML, PostScript or PDF designed for human modification.
     Examples of transparent image formats include PNG, XCF and JPG.
     Opaque formats include proprietary formats that can be read and
     edited only by proprietary word processors, SGML or XML for which
     the DTD and/or processing tools are not generally available, and
     the machine-generated HTML, PostScript or PDF produced by some word
     processors for output purposes only.

     The “Title Page” means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, “Title
     Page” means the text near the most prominent appearance of the
     work’s title, preceding the beginning of the body of the text.

     The “publisher” means any person or entity that distributes copies
     of the Document to the public.

     A section “Entitled XYZ” means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     “Acknowledgements”, “Dedications”, “Endorsements”, or “History”.)
     To “Preserve the Title” of such a section when you modify the
     Document means that it remains a section “Entitled XYZ” according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow the
     conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document’s license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the title
     equally prominent and visible.  You may add other material on the
     covers in addition.  Copying with changes limited to the covers, as
     long as they preserve the title of the Document and satisfy these
     conditions, can be treated as verbatim copying in other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a machine-readable
     Transparent copy along with each Opaque copy, or state in or with
     each Opaque copy a computer-network location from which the general
     network-using public has access to download using public-standard
     network protocols a complete Transparent copy of the Document, free
     of added material.  If you use the latter option, you must take
     reasonably prudent steps, when you begin distribution of Opaque
     copies in quantity, to ensure that this Transparent copy will
     remain thus accessible at the stated location until at least one
     year after the last time you distribute an Opaque copy (directly or
     through your agents or retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of copies,
     to give them a chance to provide you with an updated version of the
     Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with the
     Modified Version filling the role of the Document, thus licensing
     distribution and modification of the Modified Version to whoever
     possesses a copy of it.  In addition, you must do these things in
     the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of previous
          versions (which should, if there were any, be listed in the
          History section of the Document).  You may use the same title
          as a previous version if the original publisher of that
          version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document’s
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled “History”, Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on the
          Title Page.  If there is no section Entitled “History” in the
          Document, create one stating the title, year, authors, and
          publisher of the Document as given on its Title Page, then add
          an item describing the Modified Version as stated in the
          previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in the
          “History” section.  You may omit a network location for a work
          that was published at least four years before the Document
          itself, or if the original publisher of the version it refers
          to gives permission.

       K. For any section Entitled “Acknowledgements” or “Dedications”,
          Preserve the Title of the section, and preserve in the section
          all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document, unaltered
          in their text and in their titles.  Section numbers or the
          equivalent are not considered part of the section titles.

       M. Delete any section Entitled “Endorsements”.  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          “Endorsements” or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option designate
     some or all of these sections as invariant.  To do this, add their
     titles to the list of Invariant Sections in the Modified Version’s
     license notice.  These titles must be distinct from any other
     section titles.

     You may add a section Entitled “Endorsements”, provided it contains
     nothing but endorsements of your Modified Version by various
     parties—for example, statements of peer review or that the text has
     been approved by an organization as the authoritative definition of
     a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end of
     the list of Cover Texts in the Modified Version.  Only one passage
     of Front-Cover Text and one of Back-Cover Text may be added by (or
     through arrangements made by) any one entity.  If the Document
     already includes a cover text for the same cover, previously added
     by you or by arrangement made by the same entity you are acting on
     behalf of, you may not add another; but you may replace the old
     one, on explicit permission from the previous publisher that added
     the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination all
     of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     “History” in the various original documents, forming one section
     Entitled “History”; likewise combine any sections Entitled
     “Acknowledgements”, and any sections Entitled “Dedications”.  You
     must delete all sections Entitled “Endorsements.”

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the documents
     in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow this
     License in all other respects regarding verbatim copying of that
     document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of a
     storage or distribution medium, is called an “aggregate” if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation’s users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document’s Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled “Acknowledgements”,
     “Dedications”, or “History”, the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense, or distribute it is void,
     and will automatically terminate your rights under this License.

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly and
     finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from you
     under this License.  If your rights have been terminated and not
     permanently reinstated, receipt of a copy of some or all of the
     same material does not give you any rights to use it.

  10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     <http://www.gnu.org/copyleft/>.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License “or any later version” applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If the
     Document does not specify a version number of this License, you may
     choose any version ever published (not as a draft) by the Free
     Software Foundation.  If the Document specifies that a proxy can
     decide which future versions of this License can be used, that
     proxy’s public statement of acceptance of a version permanently
     authorizes you to choose that version for the Document.

  11. RELICENSING

     “Massive Multiauthor Collaboration Site” (or “MMC Site”) means any
     World Wide Web server that publishes copyrightable works and also
     provides prominent facilities for anybody to edit those works.  A
     public wiki that anybody can edit is an example of such a server.
     A “Massive Multiauthor Collaboration” (or “MMC”) contained in the
     site means any set of copyrightable works thus published on the MMC
     site.

     “CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0
     license published by Creative Commons Corporation, a not-for-profit
     corporation with a principal place of business in San Francisco,
     California, as well as future copyleft versions of that license
     published by that same organization.

     “Incorporate” means to publish or republish a Document, in whole or
     in part, as part of another Document.

     An MMC is “eligible for relicensing” if it is licensed under this
     License, and if all works that were first published under this
     License somewhere other than this MMC, and subsequently
     incorporated in whole or in part into the MMC, (1) had no cover
     texts or invariant sections, and (2) were thus incorporated prior
     to November 1, 2008.

     The operator of an MMC Site may republish an MMC contained in the
     site under CC-BY-SA on the same site at any time before August 1,
     2009, provided the MMC is eligible for relicensing.

ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.3
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the “with...Texts.” line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

   If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of free
software license, such as the GNU General Public License, to permit
their use in free software.

